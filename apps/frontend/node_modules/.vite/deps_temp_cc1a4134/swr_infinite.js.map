{
  "version": 3,
  "sources": ["../../swr/dist/infinite/index.mjs"],
  "sourcesContent": ["import { useRef, useCallback } from 'react';\nimport useSWR from '../index/index.mjs';\nimport { withMiddleware, SWRGlobalState, cache, INFINITE_PREFIX as INFINITE_PREFIX$1, createCacheHelper, isUndefined as isUndefined$1, useIsomorphicLayoutEffect, UNDEFINED as UNDEFINED$1, serialize as serialize$1, isFunction as isFunction$1 } from '../_internal/index.mjs';\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';\nimport { INFINITE_PREFIX } from '../_internal/constants.mjs';\n\n// Shared state between server components and client components\nconst noop = ()=>{};\n// Using noop() as the undefined value as undefined can be replaced\n// by something else. Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nconst UNDEFINED = /*#__NOINLINE__*/ noop();\nconst OBJECT = Object;\nconst isUndefined = (v)=>v === UNDEFINED;\nconst isFunction = (v)=>typeof v == 'function';\n\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nconst table = new WeakMap();\nconst isObjectType = (value, type)=>OBJECT.prototype.toString.call(value) === `[object ${type}]`;\n// counter of the key\nlet counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\nconst stableHash = (arg)=>{\n    const type = typeof arg;\n    const isDate = isObjectType(arg, 'Date');\n    const isRegex = isObjectType(arg, 'RegExp');\n    const isPlainObject = isObjectType(arg, 'Object');\n    let result;\n    let index;\n    if (OBJECT(arg) === arg && !isDate && !isRegex) {\n        // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n        // If it's already hashed, directly return the result.\n        result = table.get(arg);\n        if (result) return result;\n        // Store the hash first for circular reference detection before entering the\n        // recursive `stableHash` calls.\n        // For other objects like set and map, we use this id directly as the hash.\n        result = ++counter + '~';\n        table.set(arg, result);\n        if (Array.isArray(arg)) {\n            // Array.\n            result = '@';\n            for(index = 0; index < arg.length; index++){\n                result += stableHash(arg[index]) + ',';\n            }\n            table.set(arg, result);\n        }\n        if (isPlainObject) {\n            // Object, sort keys.\n            result = '#';\n            const keys = OBJECT.keys(arg).sort();\n            while(!isUndefined(index = keys.pop())){\n                if (!isUndefined(arg[index])) {\n                    result += index + ':' + stableHash(arg[index]) + ',';\n                }\n            }\n            table.set(arg, result);\n        }\n    } else {\n        result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n    }\n    return result;\n};\n\nconst serialize = (key)=>{\n    if (isFunction(key)) {\n        try {\n            key = key();\n        } catch (err) {\n            // dependencies not ready\n            key = '';\n        }\n    }\n    // Use the original key as the argument of fetcher. This can be a string or an\n    // array of values.\n    const args = key;\n    // If key is not falsy, or not an empty array, hash it.\n    key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n    return [\n        key,\n        args\n    ];\n};\n\nconst getFirstPageKey = (getKey)=>{\n    return serialize(getKey ? getKey(0, null) : null)[0];\n};\nconst unstable_serialize = (getKey)=>{\n    return INFINITE_PREFIX + getFirstPageKey(getKey);\n};\n\n// We have to several type castings here because `useSWRInfinite` is a special\n// hook where `key` and return type are not like the normal `useSWR` types.\nconst EMPTY_PROMISE = Promise.resolve();\nconst infinite = (useSWRNext)=>(getKey, fn, config)=>{\n        const didMountRef = useRef(false);\n        const { cache: cache$1, initialSize = 1, revalidateAll = false, persistSize = false, revalidateFirstPage = true, revalidateOnMount = false, parallel = false } = config;\n        const [, , , PRELOAD] = SWRGlobalState.get(cache);\n        // The serialized key of the first page. This key will be used to store\n        // metadata of this SWR infinite hook.\n        let infiniteKey;\n        try {\n            infiniteKey = getFirstPageKey(getKey);\n            if (infiniteKey) infiniteKey = INFINITE_PREFIX$1 + infiniteKey;\n        } catch (err) {\n        // Not ready yet.\n        }\n        const [get, set, subscribeCache] = createCacheHelper(cache$1, infiniteKey);\n        const getSnapshot = useCallback(()=>{\n            const size = isUndefined$1(get()._l) ? initialSize : get()._l;\n            return size;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            cache$1,\n            infiniteKey,\n            initialSize\n        ]);\n        useSyncExternalStore(useCallback((callback)=>{\n            if (infiniteKey) return subscribeCache(infiniteKey, ()=>{\n                callback();\n            });\n            return ()=>{};\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            cache$1,\n            infiniteKey\n        ]), getSnapshot, getSnapshot);\n        const resolvePageSize = useCallback(()=>{\n            const cachedPageSize = get()._l;\n            return isUndefined$1(cachedPageSize) ? initialSize : cachedPageSize;\n        // `cache` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            initialSize\n        ]);\n        // keep the last page size to restore it with the persistSize option\n        const lastPageSizeRef = useRef(resolvePageSize());\n        // When the page key changes, we reset the page size if it's not persisted\n        useIsomorphicLayoutEffect(()=>{\n            if (!didMountRef.current) {\n                didMountRef.current = true;\n                return;\n            }\n            if (infiniteKey) {\n                // If the key has been changed, we keep the current page size if persistSize is enabled\n                // Otherwise, we reset the page size to cached pageSize\n                set({\n                    _l: persistSize ? lastPageSizeRef.current : resolvePageSize()\n                });\n            }\n        // `initialSize` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            cache$1\n        ]);\n        // Needs to check didMountRef during mounting, not in the fetcher\n        const shouldRevalidateOnMount = revalidateOnMount && !didMountRef.current;\n        // Actual SWR hook to load all pages in one fetcher.\n        const swr = useSWRNext(infiniteKey, async (key)=>{\n            // get the revalidate context\n            const forceRevalidateAll = get()._i;\n            const shouldRevalidatePage = get()._r;\n            set({\n                _r: UNDEFINED$1\n            });\n            // return an array of page data\n            const data = [];\n            const pageSize = resolvePageSize();\n            const [getCache] = createCacheHelper(cache$1, key);\n            const cacheData = getCache().data;\n            const revalidators = [];\n            let previousPageData = null;\n            for(let i = 0; i < pageSize; ++i){\n                const [pageKey, pageArg] = serialize$1(getKey(i, parallel ? null : previousPageData));\n                if (!pageKey) {\n                    break;\n                }\n                const [getSWRCache, setSWRCache] = createCacheHelper(cache$1, pageKey);\n                // Get the cached page data.\n                let pageData = getSWRCache().data;\n                // should fetch (or revalidate) if:\n                // - `revalidateAll` is enabled\n                // - `mutate()` called\n                // - the cache is missing\n                // - it's the first page and it's not the initial render\n                // - `revalidateOnMount` is enabled and it's on mount\n                // - cache for that page has changed\n                const shouldFetchPage = revalidateAll || forceRevalidateAll || isUndefined$1(pageData) || revalidateFirstPage && !i && !isUndefined$1(cacheData) || shouldRevalidateOnMount || cacheData && !isUndefined$1(cacheData[i]) && !config.compare(cacheData[i], pageData);\n                if (fn && (typeof shouldRevalidatePage === 'function' ? shouldRevalidatePage(pageData, pageArg) : shouldFetchPage)) {\n                    const revalidate = async ()=>{\n                        const hasPreloadedRequest = pageKey in PRELOAD;\n                        if (!hasPreloadedRequest) {\n                            pageData = await fn(pageArg);\n                        } else {\n                            const req = PRELOAD[pageKey];\n                            // delete the preload cache key before resolving it\n                            // in case there's an error\n                            delete PRELOAD[pageKey];\n                            // get the page data from the preload cache\n                            pageData = await req;\n                        }\n                        setSWRCache({\n                            data: pageData,\n                            _k: pageArg\n                        });\n                        data[i] = pageData;\n                    };\n                    if (parallel) {\n                        revalidators.push(revalidate);\n                    } else {\n                        await revalidate();\n                    }\n                } else {\n                    data[i] = pageData;\n                }\n                if (!parallel) {\n                    previousPageData = pageData;\n                }\n            }\n            // flush all revalidateions in parallel\n            if (parallel) {\n                await Promise.all(revalidators.map((r)=>r()));\n            }\n            // once we executed the data fetching based on the context, clear the context\n            set({\n                _i: UNDEFINED$1\n            });\n            // return the data\n            return data;\n        }, config);\n        const mutate = useCallback(// eslint-disable-next-line func-names\n        function(data, opts) {\n            // When passing as a boolean, it's explicitly used to disable/enable\n            // revalidation.\n            const options = typeof opts === 'boolean' ? {\n                revalidate: opts\n            } : opts || {};\n            // Default to true.\n            const shouldRevalidate = options.revalidate !== false;\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            if (shouldRevalidate) {\n                if (!isUndefined$1(data)) {\n                    // We only revalidate the pages that are changed\n                    set({\n                        _i: false,\n                        _r: options.revalidate\n                    });\n                } else {\n                    // Calling `mutate()`, we revalidate all pages\n                    set({\n                        _i: true,\n                        _r: options.revalidate\n                    });\n                }\n            }\n            return arguments.length ? swr.mutate(data, {\n                ...options,\n                revalidate: shouldRevalidate\n            }) : swr.mutate();\n        }, // swr.mutate is always the same reference\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            cache$1\n        ]);\n        // Extend the SWR API\n        const setSize = useCallback((arg)=>{\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            const [, changeSize] = createCacheHelper(cache$1, infiniteKey);\n            let size;\n            if (isFunction$1(arg)) {\n                size = arg(resolvePageSize());\n            } else if (typeof arg == 'number') {\n                size = arg;\n            }\n            if (typeof size != 'number') return EMPTY_PROMISE;\n            changeSize({\n                _l: size\n            });\n            lastPageSizeRef.current = size;\n            // Calculate the page data after the size change.\n            const data = [];\n            const [getInfiniteCache] = createCacheHelper(cache$1, infiniteKey);\n            let previousPageData = null;\n            for(let i = 0; i < size; ++i){\n                const [pageKey] = serialize$1(getKey(i, previousPageData));\n                const [getCache] = createCacheHelper(cache$1, pageKey);\n                // Get the cached page data.\n                const pageData = pageKey ? getCache().data : UNDEFINED$1;\n                // Call `mutate` with infinte cache data if we can't get it from the page cache.\n                if (isUndefined$1(pageData)) {\n                    return mutate(getInfiniteCache().data);\n                }\n                data.push(pageData);\n                previousPageData = pageData;\n            }\n            return mutate(data);\n        }, // exclude getKey from the dependencies, which isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            cache$1,\n            mutate,\n            resolvePageSize\n        ]);\n        // Use getter functions to avoid unnecessary re-renders caused by triggering\n        // all the getters of the returned swr object.\n        return {\n            size: resolvePageSize(),\n            setSize,\n            mutate,\n            get data () {\n                return swr.data;\n            },\n            get error () {\n                return swr.error;\n            },\n            get isValidating () {\n                return swr.isValidating;\n            },\n            get isLoading () {\n                return swr.isLoading;\n            }\n        };\n    };\nconst useSWRInfinite = withMiddleware(useSWR, infinite);\n\nexport { useSWRInfinite as default, infinite, unstable_serialize };\n"],
  "mappings": "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",
  "names": ["UNDEFINED", "isUndefined", "isFunction", "serialize"]
}
