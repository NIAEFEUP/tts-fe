"use strict";
Object.defineProperty(exports, "nxCopyAssetsPlugin", {
    enumerable: true,
    get: function() {
        return nxCopyAssetsPlugin;
    }
});
const _extends = require("@swc/helpers/_/_extends");
const _nodepath = require("node:path");
const _devkit = require("@nx/devkit");
const _copyassetshandler = require("@nx/js/src/utils/assets/copy-assets-handler");
function nxCopyAssetsPlugin(_assets) {
    let config;
    let handler;
    let dispose;
    if (global.NX_GRAPH_CREATION) return;
    return {
        name: 'nx-copy-assets-plugin',
        configResolved (_config) {
            config = _config;
        },
        async buildStart () {
            const relativeProjectRoot = (0, _nodepath.relative)(_devkit.workspaceRoot, config.root);
            const assets = _assets.map((a)=>{
                if (typeof a === 'string') {
                    return (0, _devkit.joinPathFragments)(relativeProjectRoot, a);
                } else {
                    return _extends._({}, a, {
                        input: (0, _devkit.joinPathFragments)(relativeProjectRoot, a.input)
                    });
                }
            });
            handler = new _copyassetshandler.CopyAssetsHandler({
                rootDir: _devkit.workspaceRoot,
                projectDir: config.root,
                outputDir: config.build.outDir.startsWith(config.root) ? config.build.outDir : (0, _nodepath.join)(config.root, config.build.outDir),
                assets
            });
            if (this.meta.watchMode && (0, _devkit.isDaemonEnabled)()) {
                dispose = await handler.watchAndProcessOnAssetChange();
            }
        },
        async writeBundle () {
            await handler.processAllAssetsOnce();
        },
        async closeWatcher () {
            dispose == null ? void 0 : dispose();
        }
    };
}

//# sourceMappingURL=nx-copy-assets.plugin.js.map