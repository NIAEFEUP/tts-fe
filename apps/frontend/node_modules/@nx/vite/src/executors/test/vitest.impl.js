"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    vitestExecutor: function() {
        return vitestExecutor;
    }
});
const _devkit = require("@nx/devkit");
const _path = require("path");
const _internal = require("@nx/js/src/internal");
const _nxreporter = require("./lib/nx-reporter");
const _utils = require("./lib/utils");
const _executorutils = require("../../utils/executor-utils");
async function* vitestExecutor(options, context) {
    const projectRoot = context.projectsConfigurations.projects[context.projectName].root;
    (0, _internal.registerTsConfigPaths)((0, _path.resolve)(_devkit.workspaceRoot, projectRoot, 'tsconfig.json'));
    process.env.VITE_CJS_IGNORE_WARNING = 'true';
    // Allows ESM to be required in CJS modules. Vite will be published as ESM in the future.
    const { startVitest } = await (0, _executorutils.loadVitestDynamicImport)();
    var _ref;
    const resolvedOptions = (_ref = await (0, _utils.getOptions)(options, context, projectRoot)) != null ? _ref : {};
    const watch = resolvedOptions['watch'] === true;
    const nxReporter = new _nxreporter.NxReporter(watch);
    if (resolvedOptions['reporters'] === undefined) {
        resolvedOptions['reporters'] = [];
    } else if (typeof resolvedOptions['reporters'] === 'string') {
        resolvedOptions['reporters'] = [
            resolvedOptions['reporters']
        ];
    }
    resolvedOptions['reporters'].push(nxReporter);
    var _options_testFiles;
    const cliFilters = (_options_testFiles = options.testFiles) != null ? _options_testFiles : [];
    var _resolvedOptions_mode;
    const ctx = await startVitest((_resolvedOptions_mode = resolvedOptions['mode']) != null ? _resolvedOptions_mode : 'test', cliFilters, resolvedOptions);
    let hasErrors = false;
    const processExit = ()=>{
        ctx.exit();
        if (hasErrors) {
            process.exit(1);
        } else {
            process.exit(0);
        }
    };
    if (watch) {
        process.on('SIGINT', processExit);
        process.on('SIGTERM', processExit);
        process.on('exit', processExit);
    }
    // vitest sets the exitCode in case of exception without notifying reporters
    if (process.exitCode === undefined || watch && ctx.state.getFiles().length > 0) {
        for await (const report of nxReporter){
            // vitest sets the exitCode = 1 when code coverage isn't met
            hasErrors = report.hasErrors || process.exitCode && process.exitCode !== 0;
        }
    } else {
        hasErrors = process.exitCode !== 0;
    }
    return {
        success: !hasErrors
    };
}
const _default = vitestExecutor;

//# sourceMappingURL=vitest.impl.js.map