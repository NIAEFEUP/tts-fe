"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    vitePreviewServerExecutor: function() {
        return vitePreviewServerExecutor;
    }
});
const _extends = require("@swc/helpers/_/_extends");
const _devkit = require("@nx/devkit");
const _optionsutils = require("../../utils/options-utils");
const _path = require("path");
const _buildimpl = require("../build/build.impl");
const _executorutils = require("../../utils/executor-utils");
async function* vitePreviewServerExecutor(options, context) {
    var _context_projectsConfigurations_projects_target_project, _resolved_build;
    process.env.VITE_CJS_IGNORE_WARNING = 'true';
    // Allows ESM to be required in CJS modules. Vite will be published as ESM in the future.
    const { mergeConfig, preview, resolveConfig } = await (0, _executorutils.loadViteDynamicImport)();
    const projectRoot = context.projectsConfigurations.projects[context.projectName].root;
    const target = (0, _devkit.parseTargetString)(options.buildTarget, context);
    const targetConfiguration = (_context_projectsConfigurations_projects_target_project = context.projectsConfigurations.projects[target.project]) == null ? void 0 : _context_projectsConfigurations_projects_target_project.targets[target.target];
    if (!targetConfiguration) {
        throw new Error(`Invalid buildTarget: ${options.buildTarget}`);
    }
    const isCustomBuildTarget = targetConfiguration.executor !== '@nx/vite:build' && targetConfiguration.executor !== '@nrwl/vite:build';
    // Retrieve the option for the configured buildTarget.
    const buildTargetOptions = (0, _optionsutils.getNxTargetOptions)(options.buildTarget, context);
    const { configuration } = (0, _devkit.parseTargetString)(options.buildTarget, context);
    const viteConfigPath = (0, _optionsutils.normalizeViteConfigFilePath)(context.root, projectRoot, buildTargetOptions.configFile);
    const { buildOptions, otherOptions: otherOptionsFromBuild } = await (0, _buildimpl.getBuildExtraArgs)(buildTargetOptions);
    const { previewOptions, otherOptions } = await getExtraArgs(options, configuration, otherOptionsFromBuild);
    var _otherOptions_mode, _ref;
    const defaultMode = (_ref = (_otherOptions_mode = otherOptions == null ? void 0 : otherOptions.mode) != null ? _otherOptions_mode : otherOptionsFromBuild == null ? void 0 : otherOptionsFromBuild.mode) != null ? _ref : 'production';
    var _process_env_NODE_ENV;
    const resolved = await resolveConfig({
        configFile: viteConfigPath,
        mode: defaultMode
    }, 'build', defaultMode, (_process_env_NODE_ENV = process.env.NODE_ENV) != null ? _process_env_NODE_ENV : defaultMode);
    var _options_staticFilePath, _ref1;
    const outDir = (_ref1 = (_options_staticFilePath = options.staticFilePath) != null ? _options_staticFilePath : (0, _devkit.joinPathFragments)((0, _devkit.offsetFromRoot)(projectRoot), buildTargetOptions.outputPath)) != null ? _ref1 : resolved == null ? void 0 : (_resolved_build = resolved.build) == null ? void 0 : _resolved_build.outDir;
    if (!outDir) {
        throw new Error(`Could not infer the "outputPath" or "outDir". It should be set in your vite.config.ts, or as a property of the "${options.buildTarget}" buildTarget or provided explicitly as a "staticFilePath" option.`);
    }
    const root = projectRoot === '.' ? process.cwd() : (0, _path.relative)(context.cwd, (0, _devkit.joinPathFragments)(context.root, projectRoot));
    // Merge the options from the build and preview-serve targets.
    // The latter takes precedence.
    const mergedOptions = _extends._({}, {
        watch: {}
    }, {
        build: _extends._({
            outDir
        }, isCustomBuildTarget ? {} : buildOptions)
    }, isCustomBuildTarget ? {} : otherOptionsFromBuild, otherOptions, {
        preview: _extends._({}, (0, _optionsutils.getProxyConfig)(context, otherOptions.proxyConfig), previewOptions)
    });
    var _resolved_root;
    // vite InlineConfig
    const serverConfig = mergeConfig({
        // This should not be needed as it's going to be set in vite.config.ts
        // but leaving it here in case someone did not migrate correctly
        root: (_resolved_root = resolved.root) != null ? _resolved_root : root,
        configFile: viteConfigPath
    }, _extends._({}, mergedOptions));
    if (serverConfig.mode === 'production') {
        console.warn('WARNING: preview is not meant to be run in production!');
    }
    // vite PreviewServer
    let server;
    const processOnExit = async ()=>{
        await closeServer(server);
    };
    process.once('SIGINT', processOnExit);
    process.once('SIGTERM', processOnExit);
    process.once('exit', processOnExit);
    // Launch the build target.
    // If customBuildTarget is set to true, do not provide any overrides to it
    const buildTargetOverrides = isCustomBuildTarget ? {} : mergedOptions;
    const build = await (0, _devkit.runExecutor)(target, buildTargetOverrides, context);
    for await (const result of build){
        if (result.success) {
            try {
                if (!server) {
                    server = await preview(serverConfig);
                }
                server.printUrls();
                const resolvedUrls = [
                    ...server.resolvedUrls.local,
                    ...server.resolvedUrls.network
                ];
                var _resolvedUrls_;
                yield {
                    success: true,
                    baseUrl: (_resolvedUrls_ = resolvedUrls[0]) != null ? _resolvedUrls_ : ''
                };
            } catch (e) {
                console.error(e);
                yield {
                    success: false,
                    baseUrl: ''
                };
            }
        } else {
            yield {
                success: false,
                baseUrl: ''
            };
        }
    }
    await new Promise((resolve)=>{
        process.once('SIGINT', ()=>resolve());
        process.once('SIGTERM', ()=>resolve());
        process.once('exit', ()=>resolve());
    });
}
function closeServer(server) {
    return new Promise((resolve)=>{
        if (!server) {
            resolve();
        } else {
            const { httpServer } = server;
            if (httpServer['closeAllConnections']) {
                // https://github.com/vitejs/vite/pull/14834
                // closeAllConnections was added in Node v18.2.0
                // typically is "as http.Server" but no reason
                // to import http just for this
                httpServer.closeAllConnections();
            }
            httpServer.close(()=>resolve());
        }
    });
}
const _default = vitePreviewServerExecutor;
async function getExtraArgs(options, configuration, otherOptionsFromBuildTarget) {
    // support passing extra args to vite cli
    const schema = await Promise.resolve().then(()=>require("./schema.json"));
    const extraArgs = {};
    for (const key of Object.keys(options)){
        if (!schema.properties[key]) {
            extraArgs[key] = options[key];
        }
    }
    const previewOptions = {};
    const previewSchemaKeys = [
        'port',
        'strictPort',
        'host',
        'https',
        'open',
        'proxy',
        'cors',
        'headers'
    ];
    let otherOptions = {};
    for (const key of Object.keys(extraArgs)){
        if (previewSchemaKeys.includes(key)) {
            previewOptions[key] = extraArgs[key];
        } else {
            otherOptions[key] = extraArgs[key];
        }
    }
    if (configuration) {
        otherOptions = _extends._({}, otherOptions, otherOptionsFromBuildTarget != null ? otherOptionsFromBuildTarget : {});
    }
    return {
        previewOptions,
        otherOptions
    };
}

//# sourceMappingURL=preview-server.impl.js.map