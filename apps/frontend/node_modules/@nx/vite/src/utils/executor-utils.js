"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createBuildableTsConfig: function() {
        return createBuildableTsConfig;
    },
    loadViteDynamicImport: function() {
        return loadViteDynamicImport;
    },
    loadVitestDynamicImport: function() {
        return loadVitestDynamicImport;
    },
    validateTypes: function() {
        return validateTypes;
    }
});
const _devkit = require("@nx/devkit");
const _buildablelibsutils = require("@nx/js/src/utils/buildable-libs-utils");
const _optionsutils = require("./options-utils");
const _nodechild_process = require("node:child_process");
const _js = require("@nx/js");
const _path = require("path");
async function validateTypes(opts) {
    if (!opts.isVueProject) {
        const result = await (0, _js.runTypeCheck)({
            workspaceRoot: opts.workspaceRoot,
            tsConfigPath: opts.tsconfig.startsWith(opts.workspaceRoot) ? opts.tsconfig : (0, _path.join)(opts.workspaceRoot, opts.tsconfig),
            mode: 'noEmit'
        });
        await (0, _js.printDiagnostics)(result.errors, result.warnings);
        if (result.errors.length > 0) {
            throw new Error('Found type errors. See above.');
        }
    } else {
        const pm = (0, _devkit.getPackageManagerCommand)();
        const cp = (0, _nodechild_process.execSync)(`${pm.exec} vue-tsc --noEmit -p ${opts.tsconfig} --composite false`, {
            cwd: opts.workspaceRoot,
            stdio: 'inherit',
            windowsHide: false
        });
    }
}
function createBuildableTsConfig(projectRoot, options, context) {
    var _options, _buildLibsFromSource;
    var _options_tsConfig;
    const tsConfig = (_options_tsConfig = options.tsConfig) != null ? _options_tsConfig : (0, _optionsutils.getProjectTsConfigPath)(projectRoot);
    var _;
    (_ = (_options = options)[_buildLibsFromSource = 'buildLibsFromSource']) != null ? _ : _options[_buildLibsFromSource] = true;
    if (!options['buildLibsFromSource']) {
        const { dependencies } = (0, _buildablelibsutils.calculateProjectBuildableDependencies)(context.taskGraph, context.projectGraph, context.root, context.projectName, // When using incremental building and the serve target is called
        // we need to get the deps for the 'build' target instead.
        context.targetName === 'serve' ? 'build' : context.targetName, context.configurationName);
        // This tsconfig is used via the Vite ts paths plugin.
        // It can be also used by other user-defined Vite plugins (e.g. for creating type declaration files).
        const tmpTsConfigPath = (0, _buildablelibsutils.createTmpTsConfig)(tsConfig, context.root, projectRoot, dependencies);
        process.env.NX_TSCONFIG_PATH = tmpTsConfigPath;
        return tmpTsConfigPath;
    }
    return tsConfig;
}
function loadViteDynamicImport() {
    return Function('return import("vite")')();
}
function loadVitestDynamicImport() {
    return Function('return import("vitest/node")')();
}

//# sourceMappingURL=executor-utils.js.map