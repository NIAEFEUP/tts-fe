"use strict";
Object.defineProperty(exports, "ensureViteConfigIsCorrect", {
    enumerable: true,
    get: function() {
        return ensureViteConfigIsCorrect;
    }
});
const _devkit = require("@nx/devkit");
const _js = require("@nx/js");
function ensureViteConfigIsCorrect(tree, path, buildConfigString, buildConfigObject, imports, plugins, testConfigString, testConfigObject, cacheDir, projectAlreadyHasViteTargets) {
    const fileContent = tree.read(path, 'utf-8');
    let updatedContent = undefined;
    if (!(projectAlreadyHasViteTargets == null ? void 0 : projectAlreadyHasViteTargets.test) && (testConfigString == null ? void 0 : testConfigString.length)) {
        updatedContent = handleBuildOrTestNode(fileContent, testConfigString, testConfigObject, 'test');
    }
    if (!(projectAlreadyHasViteTargets == null ? void 0 : projectAlreadyHasViteTargets.build) && (buildConfigString == null ? void 0 : buildConfigString.length)) {
        updatedContent = handleBuildOrTestNode(updatedContent != null ? updatedContent : fileContent, buildConfigString, buildConfigObject, 'build');
    }
    var _handlePluginNode;
    updatedContent = (_handlePluginNode = handlePluginNode(updatedContent != null ? updatedContent : fileContent, imports, plugins)) != null ? _handlePluginNode : updatedContent;
    if (cacheDir == null ? void 0 : cacheDir.length) {
        updatedContent = handleCacheDirNode(updatedContent != null ? updatedContent : fileContent, cacheDir);
    }
    if (updatedContent) {
        tree.write(path, updatedContent);
        return true;
    } else {
        return false;
    }
}
function handleBuildOrTestNode(updatedFileContent, configContentString, configContentObject, name) {
    const { tsquery } = require('@phenomnomnominal/tsquery');
    const buildOrTestNode = tsquery.query(updatedFileContent, `PropertyAssignment:has(Identifier[name="${name}"])`);
    if (buildOrTestNode.length) {
        return tsquery.replace(updatedFileContent, `PropertyAssignment:has(Identifier[name="${name}"])`, (node)=>{
            const existingProperties = tsquery.query(node.initializer, 'PropertyAssignment');
            let updatedPropsString = '';
            for (const prop of existingProperties){
                const propName = prop.name.getText();
                if (!configContentObject[propName] && propName !== 'dir' && propName !== 'reportsDirectory' && propName !== 'provider') {
                    // NOTE: Watch for formatting.
                    updatedPropsString += `    '${propName}': ${prop.initializer.getText()},\n`;
                }
            }
            for (const [propName, propValue] of Object.entries(configContentObject)){
                // NOTE: Watch for formatting.
                if (propName === 'coverage') {
                    let propString = `    '${propName}': {\n`;
                    for (const [pName, pValue] of Object.entries(propValue)){
                        if (pName === 'provider') {
                            propString += `    '${pName}': ${pValue} as const,\n`;
                        } else {
                            propString += `    '${pName}': '${pValue}',\n`;
                        }
                    }
                    propString += `}`;
                    updatedPropsString += `${propString}\n`;
                } else if (propName === 'lib') {
                    let propString = `    '${propName}': {\n`;
                    for (const [pName, pValue] of Object.entries(propValue)){
                        if (pName === 'formats') {
                            propString += `      '${pName}': [${pValue.map((format)=>`'${format}' as const`).join(', ')}],\n`;
                        } else {
                            propString += `      '${pName}': ${JSON.stringify(pValue)},\n`;
                        }
                    }
                    propString += `    },`;
                    updatedPropsString += `${propString}\n`;
                } else {
                    updatedPropsString += `    '${propName}': ${JSON.stringify(propValue)},\n`;
                }
            }
            return `${name}: {
${updatedPropsString}  }`;
        });
    } else {
        const foundDefineConfig = tsquery.query(updatedFileContent, 'CallExpression:has(Identifier[name="defineConfig"])');
        if (foundDefineConfig.length) {
            const conditionalConfig = tsquery.query(foundDefineConfig[0], 'ArrowFunction');
            if (conditionalConfig.length) {
                if (name === 'build') {
                    return transformConditionalConfig(conditionalConfig, updatedFileContent, configContentString);
                } else {
                    // no test config in conditional config
                    return updatedFileContent;
                }
            } else {
                const propertyAssignments = tsquery.query(foundDefineConfig[0], 'PropertyAssignment');
                if (propertyAssignments.length) {
                    return (0, _devkit.applyChangesToString)(updatedFileContent, [
                        {
                            type: _devkit.ChangeType.Insert,
                            index: propertyAssignments[0].getStart(),
                            text: configContentString
                        }
                    ]);
                } else {
                    return (0, _devkit.applyChangesToString)(updatedFileContent, [
                        {
                            type: _devkit.ChangeType.Insert,
                            index: foundDefineConfig[0].getStart() + 14,
                            text: configContentString
                        }
                    ]);
                }
            }
        } else {
            // build config does not exist and defineConfig is not used
            // could also potentially be invalid syntax, so try-catch
            try {
                const defaultExport = tsquery.query(updatedFileContent, 'ExportAssignment');
                const found = tsquery.query(defaultExport == null ? void 0 : defaultExport[0], 'ObjectLiteralExpression');
                const startOfObject = found == null ? void 0 : found[0].getStart();
                return (0, _devkit.applyChangesToString)(updatedFileContent, [
                    {
                        type: _devkit.ChangeType.Insert,
                        index: startOfObject + 1,
                        text: configContentString
                    }
                ]);
            } catch (e) {
                return updatedFileContent;
            }
        }
    }
}
function transformCurrentBuildObject(index, returnStatements, appFileContent, buildConfigObject) {
    var _tsquery_query;
    if (!(returnStatements == null ? void 0 : returnStatements[index])) {
        return undefined;
    }
    const { tsquery } = require('@phenomnomnominal/tsquery');
    const currentBuildObject = (_tsquery_query = tsquery.query(returnStatements[index], 'ObjectLiteralExpression')) == null ? void 0 : _tsquery_query[0].getText();
    const currentBuildObjectStart = returnStatements[index].getStart();
    const currentBuildObjectEnd = returnStatements[index].getEnd();
    const newReturnObject = tsquery.replace(returnStatements[index].getText(), 'ObjectLiteralExpression', (_node)=>{
        return `{
        ...${currentBuildObject},
        ...${JSON.stringify(buildConfigObject)}
      }`;
    });
    const newContents = (0, _devkit.applyChangesToString)(appFileContent, [
        {
            type: _devkit.ChangeType.Delete,
            start: currentBuildObjectStart,
            length: currentBuildObjectEnd - currentBuildObjectStart
        },
        {
            type: _devkit.ChangeType.Insert,
            index: currentBuildObjectStart,
            text: newReturnObject
        }
    ]);
    return newContents;
}
function transformConditionalConfig(conditionalConfig, appFileContent, buildConfigObject) {
    const { tsquery } = require('@phenomnomnominal/tsquery');
    const { SyntaxKind } = require('typescript');
    const functionBlock = tsquery.query(conditionalConfig[0], 'Block');
    const ifStatement = tsquery.query(functionBlock == null ? void 0 : functionBlock[0], 'IfStatement');
    const binaryExpressions = tsquery.query(ifStatement == null ? void 0 : ifStatement[0], 'BinaryExpression');
    const buildExists = binaryExpressions == null ? void 0 : binaryExpressions.find((binaryExpression)=>binaryExpression.getText() === `command === 'build'`);
    const buildExistsExpressionIndex = binaryExpressions == null ? void 0 : binaryExpressions.findIndex((binaryExpression)=>binaryExpression.getText() === `command === 'build'`);
    const serveExists = binaryExpressions == null ? void 0 : binaryExpressions.find((binaryExpression)=>binaryExpression.getText() === `command === 'serve'`);
    const elseKeywordExists = (0, _js.findNodes)(ifStatement == null ? void 0 : ifStatement[0], SyntaxKind.ElseKeyword);
    const returnStatements = tsquery.query(ifStatement[0], 'ReturnStatement');
    if (!buildExists) {
        if (serveExists && elseKeywordExists) {
            var _transformCurrentBuildObject;
            // build options live inside the else block
            return (_transformCurrentBuildObject = transformCurrentBuildObject((returnStatements == null ? void 0 : returnStatements.length) - 1, returnStatements, appFileContent, buildConfigObject)) != null ? _transformCurrentBuildObject : appFileContent;
        } else {
            // no build options exist yet
            const functionBlockStart = functionBlock == null ? void 0 : functionBlock[0].getStart();
            const newContents = (0, _devkit.applyChangesToString)(appFileContent, [
                {
                    type: _devkit.ChangeType.Insert,
                    index: functionBlockStart + 1,
                    text: `
            if (command === 'build') {
              return ${JSON.stringify(buildConfigObject)}
            }
            `
                }
            ]);
            return newContents;
        }
    } else {
        var _transformCurrentBuildObject1;
        // build already exists
        // it will be the return statement which lives
        // at the buildExistsExpressionIndex
        return (_transformCurrentBuildObject1 = transformCurrentBuildObject(buildExistsExpressionIndex, returnStatements, appFileContent, buildConfigObject)) != null ? _transformCurrentBuildObject1 : appFileContent;
    }
}
function handlePluginNode(appFileContent, imports, plugins) {
    const { tsquery } = require('@phenomnomnominal/tsquery');
    const file = tsquery.ast(appFileContent);
    const pluginsNode = tsquery.query(file, 'PropertyAssignment:has(Identifier[name="plugins"])');
    let writeFile = false;
    if (pluginsNode.length) {
        appFileContent = tsquery.replace(file.getText(), 'PropertyAssignment:has(Identifier[name="plugins"])', (node)=>{
            const found = tsquery.query(node, 'ArrayLiteralExpression');
            let updatedPluginsString = '';
            var _found__elements;
            const existingPluginNodes = (_found__elements = found == null ? void 0 : found[0].elements) != null ? _found__elements : [];
            for (const plugin of existingPluginNodes){
                updatedPluginsString += `${plugin.getText()}, `;
            }
            for (const plugin of plugins){
                if (!(existingPluginNodes == null ? void 0 : existingPluginNodes.some((node)=>node.getText().includes(plugin)))) {
                    updatedPluginsString += `${plugin}, `;
                }
            }
            return `plugins: [${updatedPluginsString}]`;
        });
        writeFile = true;
    } else {
        // Plugins node does not exist yet
        // So make one from scratch
        const foundDefineConfig = tsquery.query(file, 'CallExpression:has(Identifier[name="defineConfig"])');
        if (foundDefineConfig.length) {
            const conditionalConfig = tsquery.query(foundDefineConfig[0], 'ArrowFunction');
            if (conditionalConfig.length) {
                // We are NOT transforming the conditional config
                // with plugins
                writeFile = false;
            } else {
                const propertyAssignments = tsquery.query(foundDefineConfig[0], 'PropertyAssignment');
                if (propertyAssignments.length) {
                    appFileContent = (0, _devkit.applyChangesToString)(appFileContent, [
                        {
                            type: _devkit.ChangeType.Insert,
                            index: propertyAssignments[0].getStart(),
                            text: `plugins: [${plugins.join(', ')}],`
                        }
                    ]);
                    writeFile = true;
                } else {
                    appFileContent = (0, _devkit.applyChangesToString)(appFileContent, [
                        {
                            type: _devkit.ChangeType.Insert,
                            index: foundDefineConfig[0].getStart() + 14,
                            text: `plugins: [${plugins.join(', ')}],`
                        }
                    ]);
                    writeFile = true;
                }
            }
        } else {
            // Plugins option does not exist and defineConfig is not used
            // could also potentially be invalid syntax, so try-catch
            try {
                const defaultExport = tsquery.query(file, 'ExportAssignment');
                const found = tsquery == null ? void 0 : tsquery.query(defaultExport == null ? void 0 : defaultExport[0], 'ObjectLiteralExpression');
                const startOfObject = found == null ? void 0 : found[0].getStart();
                appFileContent = (0, _devkit.applyChangesToString)(appFileContent, [
                    {
                        type: _devkit.ChangeType.Insert,
                        index: startOfObject + 1,
                        text: `plugins: [${plugins.join(', ')}],`
                    }
                ]);
                writeFile = true;
            } catch (e) {
                writeFile = false;
            }
        }
    }
    if (writeFile) {
        const filteredImports = filterImport(appFileContent, imports);
        return filteredImports.join(';\n') + '\n' + appFileContent;
    }
}
function filterImport(appFileContent, imports) {
    const { tsquery } = require('@phenomnomnominal/tsquery');
    const file = tsquery.ast(appFileContent);
    const importNodes = tsquery.query(file, ':matches(ImportDeclaration, VariableStatement)');
    const importsArrayExisting = importNodes == null ? void 0 : importNodes.map((node)=>{
        return node.getText().slice(0, -1);
    });
    return imports.filter((importString)=>{
        return !(importsArrayExisting == null ? void 0 : importsArrayExisting.includes(importString));
    });
}
function handleCacheDirNode(appFileContent, cacheDir) {
    const { tsquery } = require('@phenomnomnominal/tsquery');
    const file = tsquery.ast(appFileContent);
    const cacheDirNode = tsquery.query(file, 'PropertyAssignment:has(Identifier[name="cacheDir"])');
    if (!(cacheDirNode == null ? void 0 : cacheDirNode.length) || (cacheDirNode == null ? void 0 : cacheDirNode.length) === 0) {
        // cacheDir node does not exist yet
        // So make one from scratch
        const foundDefineConfig = tsquery.query(file, 'CallExpression:has(Identifier[name="defineConfig"])');
        if (foundDefineConfig.length) {
            const conditionalConfig = tsquery.query(foundDefineConfig[0], 'ArrowFunction');
            if (conditionalConfig.length) {
            // We are NOT transforming the conditional config
            // with cacheDir
            } else {
                const propertyAssignments = tsquery.query(foundDefineConfig[0], 'PropertyAssignment');
                if (propertyAssignments.length) {
                    appFileContent = (0, _devkit.applyChangesToString)(appFileContent, [
                        {
                            type: _devkit.ChangeType.Insert,
                            index: propertyAssignments[0].getStart(),
                            text: cacheDir
                        }
                    ]);
                } else {
                    appFileContent = (0, _devkit.applyChangesToString)(appFileContent, [
                        {
                            type: _devkit.ChangeType.Insert,
                            index: foundDefineConfig[0].getStart() + 14,
                            text: cacheDir
                        }
                    ]);
                }
            }
        } else {
            // cacheDir option does not exist and defineConfig is not used
            // could also potentially be invalid syntax, so try-catch
            try {
                const defaultExport = tsquery.query(file, 'ExportAssignment');
                const found = tsquery == null ? void 0 : tsquery.query(defaultExport == null ? void 0 : defaultExport[0], 'ObjectLiteralExpression');
                const startOfObject = found == null ? void 0 : found[0].getStart();
                appFileContent = (0, _devkit.applyChangesToString)(appFileContent, [
                    {
                        type: _devkit.ChangeType.Insert,
                        index: startOfObject + 1,
                        text: cacheDir
                    }
                ]);
            } catch (e) {}
        }
    }
    return appFileContent;
}

//# sourceMappingURL=vite-config-edit-utils.js.map