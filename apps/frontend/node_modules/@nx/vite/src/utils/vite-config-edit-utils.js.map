{"version":3,"sources":["../../../../../packages/vite/src/utils/vite-config-edit-utils.ts"],"sourcesContent":["import { applyChangesToString, ChangeType, Tree } from '@nx/devkit';\nimport { findNodes } from '@nx/js';\nimport { TargetFlags } from './generator-utils';\nimport type {\n  ArrayLiteralExpression,\n  Node,\n  PropertyAssignment,\n  ReturnStatement,\n} from 'typescript';\n\nexport function ensureViteConfigIsCorrect(\n  tree: Tree,\n  path: string,\n  buildConfigString: string,\n  buildConfigObject: {},\n  imports: string[],\n  plugins: string[],\n  testConfigString: string,\n  testConfigObject: {},\n  cacheDir: string,\n  projectAlreadyHasViteTargets?: TargetFlags\n): boolean {\n  const fileContent = tree.read(path, 'utf-8');\n\n  let updatedContent = undefined;\n\n  if (!projectAlreadyHasViteTargets?.test && testConfigString?.length) {\n    updatedContent = handleBuildOrTestNode(\n      fileContent,\n      testConfigString,\n      testConfigObject,\n      'test'\n    );\n  }\n\n  if (!projectAlreadyHasViteTargets?.build && buildConfigString?.length) {\n    updatedContent = handleBuildOrTestNode(\n      updatedContent ?? fileContent,\n      buildConfigString,\n      buildConfigObject,\n      'build'\n    );\n  }\n\n  updatedContent =\n    handlePluginNode(updatedContent ?? fileContent, imports, plugins) ??\n    updatedContent;\n\n  if (cacheDir?.length) {\n    updatedContent = handleCacheDirNode(\n      updatedContent ?? fileContent,\n      cacheDir\n    );\n  }\n\n  if (updatedContent) {\n    tree.write(path, updatedContent);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction handleBuildOrTestNode(\n  updatedFileContent: string,\n  configContentString: string,\n  configContentObject: {},\n  name: 'build' | 'test'\n): string | undefined {\n  const { tsquery } = require('@phenomnomnominal/tsquery');\n  const buildOrTestNode = tsquery.query(\n    updatedFileContent,\n    `PropertyAssignment:has(Identifier[name=\"${name}\"])`\n  );\n\n  if (buildOrTestNode.length) {\n    return tsquery.replace(\n      updatedFileContent,\n      `PropertyAssignment:has(Identifier[name=\"${name}\"])`,\n      (node: PropertyAssignment) => {\n        const existingProperties = tsquery.query(\n          node.initializer,\n          'PropertyAssignment'\n        ) as PropertyAssignment[];\n        let updatedPropsString = '';\n        for (const prop of existingProperties) {\n          const propName = prop.name.getText();\n          if (\n            !configContentObject[propName] &&\n            propName !== 'dir' &&\n            propName !== 'reportsDirectory' &&\n            propName !== 'provider'\n          ) {\n            // NOTE: Watch for formatting.\n            updatedPropsString += `    '${propName}': ${prop.initializer.getText()},\\n`;\n          }\n        }\n        for (const [propName, propValue] of Object.entries(\n          configContentObject\n        )) {\n          // NOTE: Watch for formatting.\n          if (propName === 'coverage') {\n            let propString = `    '${propName}': {\\n`;\n            for (const [pName, pValue] of Object.entries(propValue)) {\n              if (pName === 'provider') {\n                propString += `    '${pName}': ${pValue} as const,\\n`;\n              } else {\n                propString += `    '${pName}': '${pValue}',\\n`;\n              }\n            }\n            propString += `}`;\n            updatedPropsString += `${propString}\\n`;\n          } else if (propName === 'lib') {\n            let propString = `    '${propName}': {\\n`;\n            for (const [pName, pValue] of Object.entries(propValue)) {\n              if (pName === 'formats') {\n                propString += `      '${pName}': [${pValue\n                  .map((format: string) => `'${format}' as const`)\n                  .join(', ')}],\\n`;\n              } else {\n                propString += `      '${pName}': ${JSON.stringify(pValue)},\\n`;\n              }\n            }\n            propString += `    },`;\n            updatedPropsString += `${propString}\\n`;\n          } else {\n            updatedPropsString += `    '${propName}': ${JSON.stringify(\n              propValue\n            )},\\n`;\n          }\n        }\n        return `${name}: {\n${updatedPropsString}  }`;\n      }\n    );\n  } else {\n    const foundDefineConfig = tsquery.query(\n      updatedFileContent,\n      'CallExpression:has(Identifier[name=\"defineConfig\"])'\n    );\n\n    if (foundDefineConfig.length) {\n      const conditionalConfig = tsquery.query(\n        foundDefineConfig[0],\n        'ArrowFunction'\n      );\n\n      if (conditionalConfig.length) {\n        if (name === 'build') {\n          return transformConditionalConfig(\n            conditionalConfig,\n            updatedFileContent,\n            configContentString\n          );\n        } else {\n          // no test config in conditional config\n          return updatedFileContent;\n        }\n      } else {\n        const propertyAssignments = tsquery.query(\n          foundDefineConfig[0],\n          'PropertyAssignment'\n        );\n\n        if (propertyAssignments.length) {\n          return applyChangesToString(updatedFileContent, [\n            {\n              type: ChangeType.Insert,\n              index: propertyAssignments[0].getStart(),\n              text: configContentString,\n            },\n          ]);\n        } else {\n          return applyChangesToString(updatedFileContent, [\n            {\n              type: ChangeType.Insert,\n              index: foundDefineConfig[0].getStart() + 14,\n              text: configContentString,\n            },\n          ]);\n        }\n      }\n    } else {\n      // build config does not exist and defineConfig is not used\n      // could also potentially be invalid syntax, so try-catch\n      try {\n        const defaultExport = tsquery.query(\n          updatedFileContent,\n          'ExportAssignment'\n        );\n        const found = tsquery.query(\n          defaultExport?.[0],\n          'ObjectLiteralExpression'\n        );\n        const startOfObject = found?.[0].getStart();\n        return applyChangesToString(updatedFileContent, [\n          {\n            type: ChangeType.Insert,\n            index: startOfObject + 1,\n            text: configContentString,\n          },\n        ]);\n      } catch {\n        return updatedFileContent;\n      }\n    }\n  }\n}\n\nfunction transformCurrentBuildObject(\n  index: number,\n  returnStatements: ReturnStatement[],\n  appFileContent: string,\n  buildConfigObject: {}\n): string | undefined {\n  if (!returnStatements?.[index]) {\n    return undefined;\n  }\n  const { tsquery } = require('@phenomnomnominal/tsquery');\n  const currentBuildObject = tsquery\n    .query(returnStatements[index], 'ObjectLiteralExpression')?.[0]\n    .getText();\n\n  const currentBuildObjectStart = returnStatements[index].getStart();\n  const currentBuildObjectEnd = returnStatements[index].getEnd();\n  const newReturnObject = tsquery.replace(\n    returnStatements[index].getText(),\n    'ObjectLiteralExpression',\n    (_node: Node) => {\n      return `{\n        ...${currentBuildObject},\n        ...${JSON.stringify(buildConfigObject)}\n      }`;\n    }\n  );\n\n  const newContents = applyChangesToString(appFileContent, [\n    {\n      type: ChangeType.Delete,\n      start: currentBuildObjectStart,\n      length: currentBuildObjectEnd - currentBuildObjectStart,\n    },\n    {\n      type: ChangeType.Insert,\n      index: currentBuildObjectStart,\n      text: newReturnObject,\n    },\n  ]);\n\n  return newContents;\n}\n\nfunction transformConditionalConfig(\n  conditionalConfig: Node[],\n  appFileContent: string,\n  buildConfigObject: {}\n): string | undefined {\n  const { tsquery } = require('@phenomnomnominal/tsquery');\n  const { SyntaxKind } = require('typescript');\n  const functionBlock = tsquery.query(conditionalConfig[0], 'Block');\n  const ifStatement = tsquery.query(functionBlock?.[0], 'IfStatement');\n\n  const binaryExpressions = tsquery.query(ifStatement?.[0], 'BinaryExpression');\n\n  const buildExists = binaryExpressions?.find(\n    (binaryExpression) => binaryExpression.getText() === `command === 'build'`\n  );\n\n  const buildExistsExpressionIndex = binaryExpressions?.findIndex(\n    (binaryExpression) => binaryExpression.getText() === `command === 'build'`\n  );\n\n  const serveExists = binaryExpressions?.find(\n    (binaryExpression) => binaryExpression.getText() === `command === 'serve'`\n  );\n\n  const elseKeywordExists = findNodes(ifStatement?.[0], SyntaxKind.ElseKeyword);\n  const returnStatements: ReturnStatement[] = tsquery.query(\n    ifStatement[0],\n    'ReturnStatement'\n  );\n\n  if (!buildExists) {\n    if (serveExists && elseKeywordExists) {\n      // build options live inside the else block\n      return (\n        transformCurrentBuildObject(\n          returnStatements?.length - 1,\n          returnStatements,\n          appFileContent,\n          buildConfigObject\n        ) ?? appFileContent\n      );\n    } else {\n      // no build options exist yet\n      const functionBlockStart = functionBlock?.[0].getStart();\n      const newContents = applyChangesToString(appFileContent, [\n        {\n          type: ChangeType.Insert,\n          index: functionBlockStart + 1,\n          text: `\n            if (command === 'build') {\n              return ${JSON.stringify(buildConfigObject)}\n            }\n            `,\n        },\n      ]);\n      return newContents;\n    }\n  } else {\n    // build already exists\n    // it will be the return statement which lives\n    // at the buildExistsExpressionIndex\n\n    return (\n      transformCurrentBuildObject(\n        buildExistsExpressionIndex,\n        returnStatements,\n        appFileContent,\n        buildConfigObject\n      ) ?? appFileContent\n    );\n  }\n}\n\nfunction handlePluginNode(\n  appFileContent: string,\n  imports: string[],\n  plugins: string[]\n): string | undefined {\n  const { tsquery } = require('@phenomnomnominal/tsquery');\n  const file = tsquery.ast(appFileContent);\n  const pluginsNode = tsquery.query(\n    file,\n    'PropertyAssignment:has(Identifier[name=\"plugins\"])'\n  );\n\n  let writeFile = false;\n\n  if (pluginsNode.length) {\n    appFileContent = tsquery.replace(\n      file.getText(),\n      'PropertyAssignment:has(Identifier[name=\"plugins\"])',\n      (node: Node) => {\n        const found = tsquery.query(\n          node,\n          'ArrayLiteralExpression'\n        ) as ArrayLiteralExpression[];\n        let updatedPluginsString = '';\n\n        const existingPluginNodes = found?.[0].elements ?? [];\n\n        for (const plugin of existingPluginNodes) {\n          updatedPluginsString += `${plugin.getText()}, `;\n        }\n\n        for (const plugin of plugins) {\n          if (\n            !existingPluginNodes?.some((node) =>\n              node.getText().includes(plugin)\n            )\n          ) {\n            updatedPluginsString += `${plugin}, `;\n          }\n        }\n\n        return `plugins: [${updatedPluginsString}]`;\n      }\n    );\n    writeFile = true;\n  } else {\n    // Plugins node does not exist yet\n    // So make one from scratch\n\n    const foundDefineConfig = tsquery.query(\n      file,\n      'CallExpression:has(Identifier[name=\"defineConfig\"])'\n    );\n\n    if (foundDefineConfig.length) {\n      const conditionalConfig = tsquery.query(\n        foundDefineConfig[0],\n        'ArrowFunction'\n      );\n\n      if (conditionalConfig.length) {\n        // We are NOT transforming the conditional config\n        // with plugins\n        writeFile = false;\n      } else {\n        const propertyAssignments = tsquery.query(\n          foundDefineConfig[0],\n          'PropertyAssignment'\n        );\n\n        if (propertyAssignments.length) {\n          appFileContent = applyChangesToString(appFileContent, [\n            {\n              type: ChangeType.Insert,\n              index: propertyAssignments[0].getStart(),\n              text: `plugins: [${plugins.join(', ')}],`,\n            },\n          ]);\n          writeFile = true;\n        } else {\n          appFileContent = applyChangesToString(appFileContent, [\n            {\n              type: ChangeType.Insert,\n              index: foundDefineConfig[0].getStart() + 14,\n              text: `plugins: [${plugins.join(', ')}],`,\n            },\n          ]);\n          writeFile = true;\n        }\n      }\n    } else {\n      // Plugins option does not exist and defineConfig is not used\n      // could also potentially be invalid syntax, so try-catch\n      try {\n        const defaultExport = tsquery.query(file, 'ExportAssignment');\n        const found = tsquery?.query(\n          defaultExport?.[0],\n          'ObjectLiteralExpression'\n        );\n        const startOfObject = found?.[0].getStart();\n        appFileContent = applyChangesToString(appFileContent, [\n          {\n            type: ChangeType.Insert,\n            index: startOfObject + 1,\n            text: `plugins: [${plugins.join(', ')}],`,\n          },\n        ]);\n        writeFile = true;\n      } catch {\n        writeFile = false;\n      }\n    }\n  }\n  if (writeFile) {\n    const filteredImports = filterImport(appFileContent, imports);\n    return filteredImports.join(';\\n') + '\\n' + appFileContent;\n  }\n}\n\nfunction filterImport(appFileContent: string, imports: string[]): string[] {\n  const { tsquery } = require('@phenomnomnominal/tsquery');\n  const file = tsquery.ast(appFileContent);\n  const importNodes = tsquery.query(\n    file,\n    ':matches(ImportDeclaration, VariableStatement)'\n  );\n\n  const importsArrayExisting = importNodes?.map((node) => {\n    return node.getText().slice(0, -1);\n  });\n\n  return imports.filter((importString) => {\n    return !importsArrayExisting?.includes(importString);\n  });\n}\n\nfunction handleCacheDirNode(appFileContent: string, cacheDir: string): string {\n  const { tsquery } = require('@phenomnomnominal/tsquery');\n\n  const file = tsquery.ast(appFileContent);\n  const cacheDirNode = tsquery.query(\n    file,\n    'PropertyAssignment:has(Identifier[name=\"cacheDir\"])'\n  );\n\n  if (!cacheDirNode?.length || cacheDirNode?.length === 0) {\n    // cacheDir node does not exist yet\n    // So make one from scratch\n\n    const foundDefineConfig = tsquery.query(\n      file,\n      'CallExpression:has(Identifier[name=\"defineConfig\"])'\n    );\n\n    if (foundDefineConfig.length) {\n      const conditionalConfig = tsquery.query(\n        foundDefineConfig[0],\n        'ArrowFunction'\n      );\n\n      if (conditionalConfig.length) {\n        // We are NOT transforming the conditional config\n        // with cacheDir\n      } else {\n        const propertyAssignments = tsquery.query(\n          foundDefineConfig[0],\n          'PropertyAssignment'\n        );\n\n        if (propertyAssignments.length) {\n          appFileContent = applyChangesToString(appFileContent, [\n            {\n              type: ChangeType.Insert,\n              index: propertyAssignments[0].getStart(),\n              text: cacheDir,\n            },\n          ]);\n        } else {\n          appFileContent = applyChangesToString(appFileContent, [\n            {\n              type: ChangeType.Insert,\n              index: foundDefineConfig[0].getStart() + 14,\n              text: cacheDir,\n            },\n          ]);\n        }\n      }\n    } else {\n      // cacheDir option does not exist and defineConfig is not used\n      // could also potentially be invalid syntax, so try-catch\n      try {\n        const defaultExport = tsquery.query(file, 'ExportAssignment');\n        const found = tsquery?.query(\n          defaultExport?.[0],\n          'ObjectLiteralExpression'\n        );\n        const startOfObject = found?.[0].getStart();\n        appFileContent = applyChangesToString(appFileContent, [\n          {\n            type: ChangeType.Insert,\n            index: startOfObject + 1,\n            text: cacheDir,\n          },\n        ]);\n      } catch {}\n    }\n  }\n\n  return appFileContent;\n}\n"],"names":["ensureViteConfigIsCorrect","tree","path","buildConfigString","buildConfigObject","imports","plugins","testConfigString","testConfigObject","cacheDir","projectAlreadyHasViteTargets","fileContent","read","updatedContent","undefined","test","length","handleBuildOrTestNode","build","handlePluginNode","handleCacheDirNode","write","updatedFileContent","configContentString","configContentObject","name","tsquery","require","buildOrTestNode","query","replace","node","existingProperties","initializer","updatedPropsString","prop","propName","getText","propValue","Object","entries","propString","pName","pValue","map","format","join","JSON","stringify","foundDefineConfig","conditionalConfig","transformConditionalConfig","propertyAssignments","applyChangesToString","type","ChangeType","Insert","index","getStart","text","defaultExport","found","startOfObject","transformCurrentBuildObject","returnStatements","appFileContent","currentBuildObject","currentBuildObjectStart","currentBuildObjectEnd","getEnd","newReturnObject","_node","newContents","Delete","start","SyntaxKind","functionBlock","ifStatement","binaryExpressions","buildExists","find","binaryExpression","buildExistsExpressionIndex","findIndex","serveExists","elseKeywordExists","findNodes","ElseKeyword","functionBlockStart","file","ast","pluginsNode","writeFile","updatedPluginsString","existingPluginNodes","elements","plugin","some","includes","filteredImports","filterImport","importNodes","importsArrayExisting","slice","filter","importString","cacheDirNode"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}