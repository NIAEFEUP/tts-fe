"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    viteConfigurationGenerator: function() {
        return viteConfigurationGenerator;
    },
    viteConfigurationGeneratorInternal: function() {
        return viteConfigurationGeneratorInternal;
    }
});
const _extends = require("@swc/helpers/_/_extends");
const _devkit = require("@nx/devkit");
const _js = require("@nx/js");
const _getimportpath = require("@nx/js/src/utils/get-import-path");
const _tssolutionsetup = require("@nx/js/src/utils/typescript/ts-solution-setup");
const _posix = require("node:path/posix");
const _ensuredependencies = require("../../utils/ensure-dependencies");
const _generatorutils = require("../../utils/generator-utils");
const _init = require("../init/init");
const _vitestgenerator = require("../vitest/vitest-generator");
const _convertnonvite = require("./lib/convert-non-vite");
function viteConfigurationGenerator(host, schema) {
    return viteConfigurationGeneratorInternal(host, _extends._({
        addPlugin: false
    }, schema));
}
async function viteConfigurationGeneratorInternal(tree, schema) {
    var _nxJson_plugins;
    var _schema, // Setting default to jsdom since it is the most common use case (React, Web).
    // The @nx/js:lib generator specifically sets this to node to be more generic.
    _schema1, _schema2;
    const tasks = [];
    const projectConfig = (0, _devkit.readProjectConfiguration)(tree, schema.project);
    const { targets, root: projectRoot } = projectConfig;
    var _schema_projectType;
    const projectType = (0, _tssolutionsetup.getProjectType)(tree, projectConfig.root, (_schema_projectType = schema.projectType) != null ? _schema_projectType : projectConfig.projectType);
    var _includeLib;
    (_includeLib = (_schema = schema).includeLib) != null ? _includeLib : _schema.includeLib = projectType === 'library';
    var _testEnvironment;
    (_testEnvironment = (_schema1 = schema).testEnvironment) != null ? _testEnvironment : _schema1.testEnvironment = 'jsdom';
    /**
   * This is for when we are converting an existing project
   * to use the vite executors.
   */ let projectAlreadyHasViteTargets = {};
    if (!schema.newProject) {
        await (0, _convertnonvite.convertNonVite)(tree, schema, projectRoot, projectType, targets);
    }
    const jsInitTask = await (0, _js.initGenerator)(tree, _extends._({}, schema, {
        skipFormat: true,
        tsConfigName: projectRoot === '.' ? 'tsconfig.json' : 'tsconfig.base.json'
    }));
    tasks.push(jsInitTask);
    const initTask = await (0, _init.default)(tree, _extends._({}, schema, {
        projectRoot,
        skipFormat: true
    }));
    tasks.push(initTask);
    tasks.push((0, _ensuredependencies.ensureDependencies)(tree, schema));
    const nxJson = (0, _devkit.readNxJson)(tree);
    const addPluginDefault = process.env.NX_ADD_PLUGINS !== 'false' && nxJson.useInferencePlugins !== false;
    var _addPlugin;
    (_addPlugin = (_schema2 = schema).addPlugin) != null ? _addPlugin : _schema2.addPlugin = addPluginDefault;
    const hasPlugin = (_nxJson_plugins = nxJson.plugins) == null ? void 0 : _nxJson_plugins.some((p)=>typeof p === 'string' ? p === '@nx/vite/plugin' : p.plugin === '@nx/vite/plugin');
    if (!hasPlugin) {
        if (!projectAlreadyHasViteTargets.build) {
            (0, _generatorutils.addBuildTarget)(tree, schema, 'build');
        }
        if (!schema.includeLib) {
            if (!projectAlreadyHasViteTargets.serve) {
                (0, _generatorutils.addServeTarget)(tree, schema, 'serve');
            }
            if (!projectAlreadyHasViteTargets.preview) {
                (0, _generatorutils.addPreviewTarget)(tree, schema, 'preview');
            }
        }
    }
    if (projectType === 'library') {
        // update tsconfig.lib.json to include vite/client
        (0, _devkit.updateJson)(tree, (0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.lib.json'), (json)=>{
            var _json, _json_compilerOptions;
            var _compilerOptions;
            (_compilerOptions = (_json = json).compilerOptions) != null ? _compilerOptions : _json.compilerOptions = {};
            var _types;
            (_types = (_json_compilerOptions = json.compilerOptions).types) != null ? _types : _json_compilerOptions.types = [];
            if (!json.compilerOptions.types.includes('vite/client')) {
                json.compilerOptions.types.push('vite/client');
            }
            return json;
        });
    }
    if (!schema.newProject) {
        // We are converting existing project to use Vite
        if (schema.uiFramework === 'react') {
            (0, _generatorutils.createOrEditViteConfig)(tree, {
                project: schema.project,
                includeLib: schema.includeLib,
                includeVitest: schema.includeVitest,
                inSourceTests: schema.inSourceTests,
                rollupOptionsExternal: [
                    "'react'",
                    "'react-dom'",
                    "'react/jsx-runtime'"
                ],
                imports: [
                    schema.compiler === 'swc' ? `import react from '@vitejs/plugin-react-swc'` : `import react from '@vitejs/plugin-react'`
                ],
                plugins: [
                    'react()'
                ]
            }, false, undefined);
        } else {
            (0, _generatorutils.createOrEditViteConfig)(tree, schema, false, projectAlreadyHasViteTargets);
        }
    }
    if (schema.includeVitest) {
        const vitestTask = await (0, _vitestgenerator.default)(tree, {
            project: schema.project,
            uiFramework: schema.uiFramework,
            inSourceTests: schema.inSourceTests,
            coverageProvider: 'v8',
            skipViteConfig: true,
            testTarget: 'test',
            skipFormat: true,
            addPlugin: schema.addPlugin,
            compiler: schema.compiler,
            projectType
        });
        tasks.push(vitestTask);
    }
    if ((0, _tssolutionsetup.isUsingTsSolutionSetup)(tree)) {
        updatePackageJson(tree, schema, projectType);
    }
    if (!schema.skipFormat) {
        await (0, _devkit.formatFiles)(tree);
    }
    return (0, _devkit.runTasksInSerial)(...tasks);
}
const _default = viteConfigurationGenerator;
function updatePackageJson(tree, options, projectType) {
    const project = (0, _devkit.readProjectConfiguration)(tree, options.project);
    const packageJsonPath = (0, _posix.join)(project.root, 'package.json');
    let packageJson;
    if (tree.exists(packageJsonPath)) {
        packageJson = (0, _devkit.readJson)(tree, packageJsonPath);
    } else {
        packageJson = {
            name: (0, _getimportpath.getImportPath)(tree, options.project),
            version: '0.0.1'
        };
        if ((0, _tssolutionsetup.getProjectType)(tree, project.root, projectType) === 'application') {
            packageJson.private = true;
        }
    }
    if (projectType === 'library') {
        var _tsconfigBase_compilerOptions_customConditions, _tsconfigBase_compilerOptions;
        // we always write/override the vite and project config with some set values,
        // so we can rely on them
        const main = (0, _posix.join)(project.root, 'src/index.ts');
        // we configure the dts plugin with the entryRoot set to `src`
        const rootDir = (0, _posix.join)(project.root, 'src');
        const outputPath = (0, _devkit.joinPathFragments)(project.root, 'dist');
        // the file must exist in the TS solution setup, which is the only case this
        // function is called
        const tsconfigBase = (0, _devkit.readJson)(tree, 'tsconfig.base.json');
        packageJson = (0, _js.getUpdatedPackageJsonContent)(packageJson, {
            main,
            outputPath,
            projectRoot: project.root,
            rootDir,
            generateExportsField: true,
            packageJsonPath,
            format: [
                'esm'
            ],
            skipDevelopmentExports: !((_tsconfigBase_compilerOptions = tsconfigBase.compilerOptions) == null ? void 0 : (_tsconfigBase_compilerOptions_customConditions = _tsconfigBase_compilerOptions.customConditions) == null ? void 0 : _tsconfigBase_compilerOptions_customConditions.includes('development'))
        });
    }
    (0, _devkit.writeJson)(tree, packageJsonPath, packageJson);
}

//# sourceMappingURL=configuration.js.map