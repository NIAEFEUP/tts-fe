"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    vitestGenerator: function() {
        return vitestGenerator;
    },
    vitestGeneratorInternal: function() {
        return vitestGeneratorInternal;
    }
});
const _extends = require("@swc/helpers/_/_extends");
const _devkit = require("@nx/devkit");
const _js = require("@nx/js");
const _tssolutionsetup = require("@nx/js/src/utils/typescript/ts-solution-setup");
const _versions = require("@nx/js/src/utils/versions");
const _path = require("path");
const _ensuredependencies = require("../../utils/ensure-dependencies");
const _generatorutils = require("../../utils/generator-utils");
const _init = require("../init/init");
const _detectuiframework = require("../../utils/detect-ui-framework");
const _versionutils = require("../../utils/version-utils");
const _semver = require("semver");
function vitestGenerator(tree, schema, hasPlugin = false) {
    return vitestGeneratorInternal(tree, _extends._({
        addPlugin: false
    }, schema), hasPlugin);
}
async function vitestGeneratorInternal(tree, schema, hasPlugin = false) {
    var // Setting default to jsdom since it is the most common use case (React, Web).
    // The @nx/js:lib generator specifically sets this to node to be more generic.
    _schema;
    var _testEnvironment;
    (_testEnvironment = (_schema = schema).testEnvironment) != null ? _testEnvironment : _schema.testEnvironment = 'jsdom';
    const tasks = [];
    const { root, projectType: _projectType } = (0, _devkit.readProjectConfiguration)(tree, schema.project);
    var _schema_projectType;
    const projectType = (_schema_projectType = schema.projectType) != null ? _schema_projectType : _projectType;
    var _schema_uiFramework;
    const uiFramework = (_schema_uiFramework = schema.uiFramework) != null ? _schema_uiFramework : await (0, _detectuiframework.detectUiFramework)(schema.project);
    const isRootProject = root === '.';
    tasks.push(await (0, _js.initGenerator)(tree, _extends._({}, schema, {
        skipFormat: true
    })));
    const pkgJson = (0, _devkit.readJson)(tree, 'package.json');
    var _coerce;
    const useVite5 = (0, _semver.major)((_coerce = (0, _semver.coerce)(pkgJson.devDependencies['vite'])) != null ? _coerce : '6.0.0') === 5;
    const initTask = await (0, _init.default)(tree, {
        projectRoot: root,
        skipFormat: true,
        addPlugin: schema.addPlugin,
        useViteV5: useVite5
    });
    tasks.push(initTask);
    tasks.push((0, _ensuredependencies.ensureDependencies)(tree, _extends._({}, schema, {
        uiFramework
    })));
    (0, _generatorutils.addOrChangeTestTarget)(tree, schema, hasPlugin);
    if (!schema.skipViteConfig) {
        if (uiFramework === 'angular') {
            const relativeTestSetupPath = (0, _devkit.joinPathFragments)('src', 'test-setup.ts');
            const setupFile = (0, _devkit.joinPathFragments)(root, relativeTestSetupPath);
            if (!tree.exists(setupFile)) {
                tree.write(setupFile, `import '@analogjs/vitest-angular/setup-zone';

import {
  BrowserDynamicTestingModule,
  platformBrowserDynamicTesting,
} from '@angular/platform-browser-dynamic/testing';
import { getTestBed } from '@angular/core/testing';

getTestBed().initTestEnvironment(
  BrowserDynamicTestingModule,
  platformBrowserDynamicTesting()
);
`);
            }
            (0, _generatorutils.createOrEditViteConfig)(tree, {
                project: schema.project,
                includeLib: false,
                includeVitest: true,
                inSourceTests: false,
                imports: [
                    `import angular from '@analogjs/vite-plugin-angular'`
                ],
                plugins: [
                    'angular()'
                ],
                setupFile: relativeTestSetupPath,
                useEsmExtension: true
            }, true);
        } else if (uiFramework === 'react') {
            (0, _generatorutils.createOrEditViteConfig)(tree, {
                project: schema.project,
                includeLib: (0, _tssolutionsetup.getProjectType)(tree, root, projectType) === 'library',
                includeVitest: true,
                inSourceTests: schema.inSourceTests,
                rollupOptionsExternal: [
                    "'react'",
                    "'react-dom'",
                    "'react/jsx-runtime'"
                ],
                imports: [
                    schema.compiler === 'swc' ? `import react from '@vitejs/plugin-react-swc'` : `import react from '@vitejs/plugin-react'`
                ],
                plugins: [
                    'react()'
                ],
                coverageProvider: schema.coverageProvider
            }, true);
        } else {
            (0, _generatorutils.createOrEditViteConfig)(tree, _extends._({}, schema, {
                includeVitest: true,
                includeLib: (0, _tssolutionsetup.getProjectType)(tree, root, projectType) === 'library'
            }), true);
        }
    }
    const isTsSolutionSetup = (0, _tssolutionsetup.isUsingTsSolutionSetup)(tree);
    createFiles(tree, schema, root, isTsSolutionSetup);
    updateTsConfig(tree, schema, root, projectType);
    if (isTsSolutionSetup) {
        var _nxJson, _nxJson_targetDefaults, _testTarget, _nxJson_targetDefaults_testTarget;
        // in the TS solution setup, the test target depends on the build outputs
        // so we need to setup the task pipeline accordingly
        const nxJson = (0, _devkit.readNxJson)(tree);
        var _schema_testTarget;
        const testTarget = (_schema_testTarget = schema.testTarget) != null ? _schema_testTarget : 'test';
        var _targetDefaults;
        (_targetDefaults = (_nxJson = nxJson).targetDefaults) != null ? _targetDefaults : _nxJson.targetDefaults = {};
        var _;
        (_ = (_nxJson_targetDefaults = nxJson.targetDefaults)[_testTarget = testTarget]) != null ? _ : _nxJson_targetDefaults[_testTarget] = {};
        var _dependsOn;
        (_dependsOn = (_nxJson_targetDefaults_testTarget = nxJson.targetDefaults[testTarget]).dependsOn) != null ? _dependsOn : _nxJson_targetDefaults_testTarget.dependsOn = [];
        nxJson.targetDefaults[testTarget].dependsOn = Array.from(new Set([
            ...nxJson.targetDefaults[testTarget].dependsOn,
            '^build'
        ]));
        (0, _devkit.updateNxJson)(tree, nxJson);
    }
    const devDependencies = await getCoverageProviderDependency(tree, schema.coverageProvider);
    devDependencies['@types/node'] = _versions.typesNodeVersion;
    const installDependenciesTask = (0, _devkit.addDependenciesToPackageJson)(tree, {}, devDependencies);
    tasks.push(installDependenciesTask);
    // Setup workspace config file (https://vitest.dev/guide/workspace.html)
    if (!isRootProject && !tree.exists(`vitest.workspace.ts`) && !tree.exists(`vitest.workspace.js`) && !tree.exists(`vitest.workspace.json`) && !tree.exists(`vitest.projects.ts`) && !tree.exists(`vitest.projects.js`) && !tree.exists(`vitest.projects.json`)) {
        tree.write('vitest.workspace.ts', `export default ['**/vite.config.{mjs,js,ts,mts}', '**/vitest.config.{mjs,js,ts,mts}'];`);
    }
    if (!schema.skipFormat) {
        await (0, _devkit.formatFiles)(tree);
    }
    return (0, _devkit.runTasksInSerial)(...tasks);
}
function updateTsConfig(tree, options, projectRoot, projectType) {
    const setupFile = tryFindSetupFile(tree, projectRoot);
    if (tree.exists((0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.spec.json'))) {
        (0, _devkit.updateJson)(tree, (0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.spec.json'), (json)=>{
            var _json_compilerOptions_types, _json_compilerOptions;
            if (!((_json_compilerOptions = json.compilerOptions) == null ? void 0 : (_json_compilerOptions_types = _json_compilerOptions.types) == null ? void 0 : _json_compilerOptions_types.includes('vitest'))) {
                var _json_compilerOptions1;
                if ((_json_compilerOptions1 = json.compilerOptions) == null ? void 0 : _json_compilerOptions1.types) {
                    json.compilerOptions.types.push('vitest');
                } else {
                    var _json;
                    var _compilerOptions;
                    (_compilerOptions = (_json = json).compilerOptions) != null ? _compilerOptions : _json.compilerOptions = {};
                    json.compilerOptions.types = [
                        'vitest'
                    ];
                }
            }
            if (setupFile) {
                var _json_files;
                json.files = [
                    ...(_json_files = json.files) != null ? _json_files : [],
                    setupFile
                ];
            }
            return json;
        });
        (0, _devkit.updateJson)(tree, (0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.json'), (json)=>{
            if (json.references && !json.references.some((r)=>r.path === './tsconfig.spec.json')) {
                json.references.push({
                    path: './tsconfig.spec.json'
                });
            }
            return json;
        });
    } else {
        (0, _devkit.updateJson)(tree, (0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.json'), (json)=>{
            var _json_compilerOptions_types, _json_compilerOptions;
            if (!((_json_compilerOptions = json.compilerOptions) == null ? void 0 : (_json_compilerOptions_types = _json_compilerOptions.types) == null ? void 0 : _json_compilerOptions_types.includes('vitest'))) {
                var _json_compilerOptions1;
                if ((_json_compilerOptions1 = json.compilerOptions) == null ? void 0 : _json_compilerOptions1.types) {
                    json.compilerOptions.types.push('vitest');
                } else {
                    var _json;
                    var _compilerOptions;
                    (_compilerOptions = (_json = json).compilerOptions) != null ? _compilerOptions : _json.compilerOptions = {};
                    json.compilerOptions.types = [
                        'vitest'
                    ];
                }
            }
            return json;
        });
    }
    let runtimeTsconfigPath = (0, _devkit.joinPathFragments)(projectRoot, (0, _tssolutionsetup.getProjectType)(tree, projectRoot, projectType) === 'application' ? 'tsconfig.app.json' : 'tsconfig.lib.json');
    if (options.runtimeTsconfigFileName) {
        runtimeTsconfigPath = (0, _devkit.joinPathFragments)(projectRoot, options.runtimeTsconfigFileName);
        if (!tree.exists(runtimeTsconfigPath)) {
            throw new Error(`Cannot find the specified runtimeTsConfigFileName ("${options.runtimeTsconfigFileName}") at the project root "${projectRoot}".`);
        }
    }
    if (tree.exists(runtimeTsconfigPath)) {
        (0, _devkit.updateJson)(tree, runtimeTsconfigPath, (json)=>{
            if (options.inSourceTests) {
                var _json_compilerOptions;
                var _types;
                ((_types = (_json_compilerOptions = json.compilerOptions).types) != null ? _types : _json_compilerOptions.types = []).push('vitest/importMeta');
            } else {
                const uniqueExclude = new Set([
                    ...json.exclude || [],
                    'vite.config.ts',
                    'vite.config.mts',
                    'vitest.config.ts',
                    'vitest.config.mts',
                    'src/**/*.test.ts',
                    'src/**/*.spec.ts',
                    'src/**/*.test.tsx',
                    'src/**/*.spec.tsx',
                    'src/**/*.test.js',
                    'src/**/*.spec.js',
                    'src/**/*.test.jsx',
                    'src/**/*.spec.jsx'
                ]);
                json.exclude = [
                    ...uniqueExclude
                ];
            }
            if (setupFile) {
                var _json_exclude;
                json.exclude = [
                    ...(_json_exclude = json.exclude) != null ? _json_exclude : [],
                    setupFile
                ];
            }
            return json;
        });
    } else {
        _devkit.logger.warn(`Couldn't find a runtime tsconfig file at ${runtimeTsconfigPath} to exclude the test files from. ` + `If you're using a different filename for your runtime tsconfig, please provide it with the '--runtimeTsconfigFileName' flag.`);
    }
}
function createFiles(tree, options, projectRoot, isTsSolutionSetup) {
    const rootOffset = (0, _devkit.offsetFromRoot)(projectRoot);
    (0, _devkit.generateFiles)(tree, (0, _path.join)(__dirname, 'files'), projectRoot, _extends._({
        tmpl: ''
    }, options, {
        projectRoot,
        extendedConfig: isTsSolutionSetup ? `${rootOffset}tsconfig.base.json` : './tsconfig.json',
        outDir: isTsSolutionSetup ? `./out-tsc/vitest` : `${rootOffset}dist/out-tsc`
    }));
}
async function getCoverageProviderDependency(tree, coverageProvider) {
    const { vitestCoverageV8, vitestCoverageIstanbul } = await (0, _versionutils.getVitestDependenciesVersionsToInstall)(tree);
    switch(coverageProvider){
        case 'v8':
            return {
                '@vitest/coverage-v8': vitestCoverageV8
            };
        case 'istanbul':
            return {
                '@vitest/coverage-istanbul': vitestCoverageIstanbul
            };
        default:
            return {
                '@vitest/coverage-v8': vitestCoverageV8
            };
    }
}
function tryFindSetupFile(tree, projectRoot) {
    const setupFile = (0, _devkit.joinPathFragments)('src', 'test-setup.ts');
    if (tree.exists((0, _devkit.joinPathFragments)(projectRoot, setupFile))) {
        return setupFile;
    }
}
const _default = vitestGenerator;

//# sourceMappingURL=vitest-generator.js.map