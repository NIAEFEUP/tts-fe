"use strict";
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return fixCoverageThreshold;
    }
});
const _devkit = require("@nx/devkit");
const _executoroptionsutils = require("@nx/devkit/src/generators/executor-options-utils");
const _fixcoverageandreporters = require("./lib/fix-coverage-and-reporters");
async function fixCoverageThreshold(tree) {
    const projects = (0, _devkit.getProjects)(tree);
    (0, _executoroptionsutils.forEachExecutorOptions)(tree, '@nx/vite:test', (_options, projectName)=>{
        const projectConfig = projects.get(projectName);
        const configPath = findViteConfig(tree, projectConfig.root);
        if (!configPath || !tree.exists(configPath)) {
            return;
        }
        const configContents = tree.read(configPath, 'utf-8');
        const updatedConfigContents = (0, _fixcoverageandreporters.fixCoverageAndRerporters)(configContents);
        if (updatedConfigContents) {
            tree.write(configPath, updatedConfigContents);
        }
    });
    await (0, _devkit.formatFiles)(tree);
}
function findViteConfig(tree, searchRoot) {
    const allowsExt = [
        'js',
        'mjs',
        'ts',
        'cjs',
        'mts',
        'cts'
    ];
    for (const ext of allowsExt){
        if (tree.exists((0, _devkit.joinPathFragments)(searchRoot, `vite.config.${ext}`))) {
            return (0, _devkit.joinPathFragments)(searchRoot, `vite.config.${ext}`);
        } else if (tree.exists((0, _devkit.joinPathFragments)(searchRoot, `vitest.config.${ext}`))) {
            return (0, _devkit.joinPathFragments)(searchRoot, `vitest.config.${ext}`);
        }
    }
}

//# sourceMappingURL=vitest-coverage-and-reporters.js.map