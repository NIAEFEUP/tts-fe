"use strict";
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _devkit = require("@nx/devkit");
const _tsquery = require("@phenomnomnominal/tsquery");
const _minimatch = require("minimatch");
const REMIX_IMPORT_SELECTOR = 'ImportDeclaration:has(StringLiteral[value=@remix-run/dev]),CallExpression:has(Identifier[name=require]) StringLiteral[value=@remix-run/dev]';
const DEFINE_CONFIG_OBJECT_SELECTOR = `CallExpression:has(Identifier[name=defineConfig]) > ObjectLiteralExpression`;
const RESOLVE_PROPERTY_SELECTOR = `PropertyAssignment:has(Identifier[name=resolve]) > ObjectLiteralExpression`;
const CONDITIONS_PROPERTY_SELECTOR = `PropertyAssignment:has(Identifier[name=conditions]) > ArrayLiteralExpression`;
const _conditions_array_values = [
    'module',
    'browser',
    'development|production'
];
const _condition_obj = `conditions: ${JSON.stringify(_conditions_array_values)},`;
const _resolve = `resolve: {
  ${_condition_obj}
},`;
async function _default(tree) {
    const viteFiles = [];
    (0, _devkit.visitNotIgnoredFiles)(tree, '', (filePath)=>{
        if ((0, _minimatch.minimatch)(filePath, '**/vite.*config*.{js,ts,mjs,mts,cjs,cts}')) {
            viteFiles.push(filePath);
        }
    });
    for (const file of viteFiles){
        const contents = tree.read(file, 'utf-8');
        const ast = _tsquery.tsquery.ast(contents);
        const remixImportNodes = (0, _tsquery.tsquery)(ast, REMIX_IMPORT_SELECTOR, {
            visitAllChildren: true
        });
        if (remixImportNodes.length > 0) {
            continue;
        }
        const defineConfigObjectNodes = (0, _tsquery.tsquery)(ast, DEFINE_CONFIG_OBJECT_SELECTOR);
        if (defineConfigObjectNodes.length === 0) {
            console.warn(`Could not migrate vite config at ${file}. No "defineConfig" object found. Apply "resolve.conditions: ['module', 'browser', 'development|production']" manually to your vite config.`);
            continue;
        }
        let newContents = contents;
        const defineConfigObjectNode = defineConfigObjectNodes[0];
        const resolvePropertyNodes = (0, _tsquery.tsquery)(defineConfigObjectNode, RESOLVE_PROPERTY_SELECTOR);
        if (resolvePropertyNodes.length === 0) {
            continue;
        } else {
            const resolvePropertyNode = resolvePropertyNodes[0];
            const conditionsPropertyNodes = (0, _tsquery.tsquery)(resolvePropertyNode, CONDITIONS_PROPERTY_SELECTOR);
            if (conditionsPropertyNodes.length === 0) {
                continue;
            } else {
                const conditionPropertyNode = conditionsPropertyNodes[0];
                const conditionsArrayValues = JSON.parse(conditionPropertyNode.getText().replace(/['`]/g, '"'));
                const newConditionArrayValues = [
                    ...new Set([
                        ...conditionsArrayValues,
                        ..._conditions_array_values
                    ])
                ];
                newContents = newContents.slice(0, conditionPropertyNode.getStart()) + `${JSON.stringify(newConditionArrayValues)}` + newContents.slice(conditionPropertyNode.getEnd());
            }
        }
        tree.write(file, newContents);
    }
    await (0, _devkit.formatFiles)(tree);
}

//# sourceMappingURL=update-resolve-conditions.js.map