"use strict";
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return update;
    }
});
const _devkit = require("@nx/devkit");
const _executoroptionsutils = require("@nx/devkit/src/generators/executor-options-utils");
const _projectconfigurationutils = require("nx/src/project-graph/utils/project-configuration-utils");
async function update(tree) {
    var _nxJson_targetDefaults, _nxJson_namedInputs;
    var _nxJson, _vitestDefaults, _vitestDefaults1;
    const nxJson = (0, _devkit.readNxJson)(tree);
    // Don't override anything if there are already target defaults for vitest
    if ((_nxJson_targetDefaults = nxJson.targetDefaults) == null ? void 0 : _nxJson_targetDefaults['@nx/vite:test']) {
        return;
    }
    var _targetDefaults;
    (_targetDefaults = (_nxJson = nxJson).targetDefaults) != null ? _targetDefaults : _nxJson.targetDefaults = {};
    /**
   * A set of targets which does not use any other executors
   */ const vitestTargets = new Set();
    const graph = await (0, _devkit.createProjectGraphAsync)();
    const projectMap = (0, _devkit.getProjects)(tree);
    (0, _executoroptionsutils.forEachExecutorOptionsInGraph)(graph, '@nx/vite:test', (value, proj, targetName)=>{
        vitestTargets.add(targetName);
    });
    // Workspace does not use vitest
    if (vitestTargets.size === 0) {
        return;
    }
    // Use the project graph nodes so that targets which are inferred are considered
    const projects = graph.nodes;
    const vitestDefaults = nxJson.targetDefaults['@nx/vite:test'] = {};
    // All vitest targets have the same name
    if (vitestTargets.size === 1) {
        const targetName = Array.from(vitestTargets)[0];
        if (nxJson.targetDefaults[targetName]) {
            Object.assign(vitestDefaults, nxJson.targetDefaults[targetName]);
        }
    }
    var _cache;
    (_cache = (_vitestDefaults = vitestDefaults).cache) != null ? _cache : _vitestDefaults.cache = true;
    const inputs = [
        'default'
    ];
    inputs.push(((_nxJson_namedInputs = nxJson.namedInputs) == null ? void 0 : _nxJson_namedInputs.production) ? '^production' : '^default');
    var _inputs;
    (_inputs = (_vitestDefaults1 = vitestDefaults).inputs) != null ? _inputs : _vitestDefaults1.inputs = inputs;
    // Cleanup old target defaults
    for (const [targetDefaultKey, targetDefault] of Object.entries(nxJson.targetDefaults)){
        if (!isTargetDefaultUsed(targetDefault, nxJson.targetDefaults, projects, projectMap)) {
            delete nxJson.targetDefaults[targetDefaultKey];
        }
    }
    (0, _devkit.updateNxJson)(tree, nxJson);
    await (0, _devkit.formatFiles)(tree);
}
/**
 * Checks every target on every project to see if one of them uses the target default
 */ function isTargetDefaultUsed(targetDefault, targetDefaults, projects, projectMap) {
    for (const p of Object.values(projects)){
        var _p_data;
        var _p_data_targets;
        for(const targetName in (_p_data_targets = (_p_data = p.data) == null ? void 0 : _p_data.targets) != null ? _p_data_targets : {}){
            var // It might seem like we should use the graph here too but we don't want to pass an executor which was processed in the graph
            _projectMap_get_targets_targetName, _projectMap_get_targets;
            if ((0, _projectconfigurationutils.readTargetDefaultsForTarget)(targetName, targetDefaults, (_projectMap_get_targets = projectMap.get(p.name).targets) == null ? void 0 : (_projectMap_get_targets_targetName = _projectMap_get_targets[targetName]) == null ? void 0 : _projectMap_get_targets_targetName.executor) === targetDefault) {
                return true;
            }
        }
    }
    return false;
}

//# sourceMappingURL=move-target-defaults.js.map