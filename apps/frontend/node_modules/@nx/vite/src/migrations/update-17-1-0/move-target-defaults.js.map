{"version":3,"sources":["../../../../../../packages/vite/src/migrations/update-17-1-0/move-target-defaults.ts"],"sourcesContent":["import {\n  createProjectGraphAsync,\n  formatFiles,\n  getProjects,\n  ProjectConfiguration,\n  ProjectGraphProjectNode,\n  readNxJson,\n  TargetConfiguration,\n  TargetDefaults,\n  Tree,\n  updateNxJson,\n} from '@nx/devkit';\nimport { forEachExecutorOptionsInGraph } from '@nx/devkit/src/generators/executor-options-utils';\nimport { VitestExecutorOptions } from '../../executors/test/schema';\nimport { readTargetDefaultsForTarget } from 'nx/src/project-graph/utils/project-configuration-utils';\n\nexport default async function update(tree: Tree) {\n  const nxJson = readNxJson(tree);\n\n  // Don't override anything if there are already target defaults for vitest\n  if (nxJson.targetDefaults?.['@nx/vite:test']) {\n    return;\n  }\n\n  nxJson.targetDefaults ??= {};\n\n  /**\n   * A set of targets which does not use any other executors\n   */\n  const vitestTargets = new Set<string>();\n  const graph = await createProjectGraphAsync();\n  const projectMap = getProjects(tree);\n\n  forEachExecutorOptionsInGraph(\n    graph,\n    '@nx/vite:test',\n    (value, proj, targetName) => {\n      vitestTargets.add(targetName);\n    }\n  );\n\n  // Workspace does not use vitest\n  if (vitestTargets.size === 0) {\n    return;\n  }\n\n  // Use the project graph nodes so that targets which are inferred are considered\n  const projects = graph.nodes;\n\n  const vitestDefaults: TargetConfiguration<Partial<VitestExecutorOptions>> =\n    (nxJson.targetDefaults['@nx/vite:test'] = {});\n\n  // All vitest targets have the same name\n  if (vitestTargets.size === 1) {\n    const targetName = Array.from(vitestTargets)[0];\n    if (nxJson.targetDefaults[targetName]) {\n      Object.assign(vitestDefaults, nxJson.targetDefaults[targetName]);\n    }\n  }\n\n  vitestDefaults.cache ??= true;\n\n  const inputs = ['default'];\n  inputs.push(nxJson.namedInputs?.production ? '^production' : '^default');\n  vitestDefaults.inputs ??= inputs;\n\n  // Cleanup old target defaults\n  for (const [targetDefaultKey, targetDefault] of Object.entries(\n    nxJson.targetDefaults\n  )) {\n    if (\n      !isTargetDefaultUsed(\n        targetDefault,\n        nxJson.targetDefaults,\n        projects,\n        projectMap\n      )\n    ) {\n      delete nxJson.targetDefaults[targetDefaultKey];\n    }\n  }\n\n  updateNxJson(tree, nxJson);\n\n  await formatFiles(tree);\n}\n\n/**\n * Checks every target on every project to see if one of them uses the target default\n */\nfunction isTargetDefaultUsed(\n  targetDefault: Partial<TargetConfiguration>,\n  targetDefaults: TargetDefaults,\n  projects: Record<string, ProjectGraphProjectNode>,\n  projectMap: Map<string, ProjectConfiguration>\n) {\n  for (const p of Object.values(projects)) {\n    for (const targetName in p.data?.targets ?? {}) {\n      if (\n        readTargetDefaultsForTarget(\n          targetName,\n          targetDefaults,\n          // It might seem like we should use the graph here too but we don't want to pass an executor which was processed in the graph\n          projectMap.get(p.name).targets?.[targetName]?.executor\n        ) === targetDefault\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n"],"names":["update","tree","nxJson","vitestDefaults","readNxJson","targetDefaults","vitestTargets","Set","graph","createProjectGraphAsync","projectMap","getProjects","forEachExecutorOptionsInGraph","value","proj","targetName","add","size","projects","nodes","Array","from","Object","assign","cache","inputs","push","namedInputs","production","targetDefaultKey","targetDefault","entries","isTargetDefaultUsed","updateNxJson","formatFiles","p","values","data","targets","readTargetDefaultsForTarget","get","name","executor"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";+BAgBA;;;eAA8BA;;;wBALvB;sCACuC;2CAEF;AAE7B,eAAeA,OAAOC,IAAU;QAIzCC,wBA2CQA;QAvCZA,SAoCAC,iBAIAA;IA/CA,MAAMD,SAASE,IAAAA,kBAAU,EAACH;IAE1B,0EAA0E;IAC1E,KAAIC,yBAAAA,OAAOG,cAAc,qBAArBH,sBAAuB,CAAC,gBAAgB,EAAE;QAC5C;IACF;;IAEAA,oBAAAA,UAAAA,QAAOG,4CAAPH,QAAOG,iBAAmB,CAAC;IAE3B;;GAEC,GACD,MAAMC,gBAAgB,IAAIC;IAC1B,MAAMC,QAAQ,MAAMC,IAAAA,+BAAuB;IAC3C,MAAMC,aAAaC,IAAAA,mBAAW,EAACV;IAE/BW,IAAAA,mDAA6B,EAC3BJ,OACA,iBACA,CAACK,OAAOC,MAAMC;QACZT,cAAcU,GAAG,CAACD;IACpB;IAGF,gCAAgC;IAChC,IAAIT,cAAcW,IAAI,KAAK,GAAG;QAC5B;IACF;IAEA,gFAAgF;IAChF,MAAMC,WAAWV,MAAMW,KAAK;IAE5B,MAAMhB,iBACHD,OAAOG,cAAc,CAAC,gBAAgB,GAAG,CAAC;IAE7C,wCAAwC;IACxC,IAAIC,cAAcW,IAAI,KAAK,GAAG;QAC5B,MAAMF,aAAaK,MAAMC,IAAI,CAACf,cAAc,CAAC,EAAE;QAC/C,IAAIJ,OAAOG,cAAc,CAACU,WAAW,EAAE;YACrCO,OAAOC,MAAM,CAACpB,gBAAgBD,OAAOG,cAAc,CAACU,WAAW;QACjE;IACF;;IAEAZ,WAAAA,kBAAAA,gBAAeqB,0BAAfrB,gBAAeqB,QAAU;IAEzB,MAAMC,SAAS;QAAC;KAAU;IAC1BA,OAAOC,IAAI,CAACxB,EAAAA,sBAAAA,OAAOyB,WAAW,qBAAlBzB,oBAAoB0B,UAAU,IAAG,gBAAgB;;IAC7DzB,YAAAA,mBAAAA,gBAAesB,4BAAftB,iBAAesB,SAAWA;IAE1B,8BAA8B;IAC9B,KAAK,MAAM,CAACI,kBAAkBC,cAAc,IAAIR,OAAOS,OAAO,CAC5D7B,OAAOG,cAAc,EACpB;QACD,IACE,CAAC2B,oBACCF,eACA5B,OAAOG,cAAc,EACrBa,UACAR,aAEF;YACA,OAAOR,OAAOG,cAAc,CAACwB,iBAAiB;QAChD;IACF;IAEAI,IAAAA,oBAAY,EAAChC,MAAMC;IAEnB,MAAMgC,IAAAA,mBAAW,EAACjC;AACpB;AAEA;;CAEC,GACD,SAAS+B,oBACPF,aAA2C,EAC3CzB,cAA8B,EAC9Ba,QAAiD,EACjDR,UAA6C;IAE7C,KAAK,MAAMyB,KAAKb,OAAOc,MAAM,CAAClB,UAAW;YACdiB;YAAAA;QAAzB,IAAK,MAAMpB,cAAcoB,CAAAA,mBAAAA,UAAAA,EAAEE,IAAI,qBAANF,QAAQG,OAAO,YAAfH,kBAAmB,CAAC,EAAG;gBAK1C,6HAA6H;YAC7HzB,oCAAAA;YALJ,IACE6B,IAAAA,sDAA2B,EACzBxB,YACAV,iBAEAK,0BAAAA,WAAW8B,GAAG,CAACL,EAAEM,IAAI,EAAEH,OAAO,sBAA9B5B,qCAAAA,uBAAgC,CAACK,WAAW,qBAA5CL,mCAA8CgC,QAAQ,MAClDZ,eACN;gBACA,OAAO;YACT;QACF;IACF;IACA,OAAO;AACT"}