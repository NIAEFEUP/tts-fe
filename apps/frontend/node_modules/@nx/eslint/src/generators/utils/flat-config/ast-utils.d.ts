import { Linter } from 'eslint';
import * as ts from 'typescript';
/**
 * Remove all overrides from the config file
 */
export declare function removeOverridesFromLintConfig(content: string): string;
export declare function addPatternsToFlatConfigIgnoresBlock(content: string, ignorePatterns: string[]): string;
export declare function hasFlatConfigIgnoresBlock(content: string): boolean;
export declare function hasOverride(content: string, lookup: (override: Linter.ConfigOverride<Linter.RulesRecord>) => boolean): boolean;
/**
 * Finds an override matching the lookup function and applies the update function to it
 */
export declare function replaceOverride(content: string, root: string, lookup: (override: Linter.ConfigOverride<Linter.RulesRecord>) => boolean, update?: (override: Partial<Linter.ConfigOverride<Linter.RulesRecord>>) => Partial<Linter.ConfigOverride<Linter.RulesRecord>>): string;
/**
 * Adding import statement to the top of the file
 * The imports are added based on a few rules:
 * 1. If it's a default import and matches the variable, return content unchanged.
 * 2. If it's a named import and the variables are not part of the import object, add them.
 * 3. If no existing import and variable is a string, add a default import.
 * 4. If no existing import and variable is an array, add it as an object import.
 */
export declare function addImportToFlatConfig(content: string, variable: string | string[], imp: string): string;
/**
 * Remove an import from flat config
 */
export declare function removeImportFromFlatConfig(content: string, variable: string, imp: string): string;
/**
 * Injects new ts.expression to the end of the module.exports or export default array.
 */
export declare function addBlockToFlatConfigExport(content: string, config: ts.Expression | ts.SpreadElement, options?: {
    insertAtTheEnd?: boolean;
    checkBaseConfig?: boolean;
}): string;
export declare function removePlugin(content: string, pluginName: string, pluginImport: string): string;
export declare function removeCompatExtends(content: string, compatExtends: string[]): string;
export declare function removePredefinedConfigs(content: string, moduleImport: string, moduleVariable: string, configs: string[]): string;
/**
 * Add plugins block to the top of the export blocks
 */
export declare function addPluginsToExportsBlock(content: string, plugins: {
    name: string;
    varName: string;
    imp: string;
}[]): string;
/**
 * Adds compat if missing to flat config
 */
export declare function addFlatCompatToFlatConfig(content: string): string;
/**
 * Generate node list representing the imports and the exports blocks
 * Optionally add flat compat initialization
 */
export declare function createNodeList(importsMap: Map<string, string>, exportElements: ts.Expression[], format: 'mjs' | 'cjs'): ts.NodeArray<ts.VariableStatement | ts.Identifier | ts.ExpressionStatement | ts.SourceFile>;
export declare function generateSpreadElement(name: string): ts.SpreadElement;
export declare function generatePluginExtendsElement(plugins: string[]): ts.SpreadElement;
export declare function generatePluginExtendsElementWithCompatFixup(plugin: string): ts.SpreadElement;
/**
 * Stringifies TS nodes to file content string
 */
export declare function stringifyNodeList(nodes: ts.NodeArray<ts.VariableStatement | ts.Identifier | ts.ExpressionStatement | ts.SourceFile>): string;
/**
 * generates AST require statement
 */
export declare function generateRequire(variableName: string | ts.ObjectBindingPattern, imp: string): ts.VariableStatement;
export declare function generateESMImport(variableName: string | ts.ObjectBindingPattern, imp: string): ts.ImportDeclaration;
export declare function overrideNeedsCompat(override: Partial<Linter.ConfigOverride<Linter.RulesRecord>>): string | string[] | {
    [name: string]: boolean;
};
/**
 * Generates an AST object or spread element representing a modern flat config entry,
 * based on a given legacy eslintrc JSON override object
 */
export declare function generateFlatOverride(_override: Partial<Linter.ConfigOverride<Linter.RulesRecord>> & {
    ignores?: Linter.FlatConfig['ignores'];
}, format: 'mjs' | 'cjs'): ts.ObjectLiteralExpression | ts.SpreadElement;
export declare function generateFlatPredefinedConfig(predefinedConfigName: string, moduleName?: string, spread?: boolean): ts.ObjectLiteralExpression | ts.SpreadElement | ts.ElementAccessExpression;
export declare function mapFilePaths<T extends Partial<Linter.ConfigOverride<Linter.RulesRecord>>>(_override: T): T;
/**
 * Generates an AST from a JSON-type input
 */
export declare function generateAst<T>(input: unknown, propertyAssignmentReplacer?: {
    keyToMatch: RegExp | string;
    replacer: (propertyAssignment: ts.PropertyAssignment, propertyName: string) => ts.PropertyAssignment;
}): T;
