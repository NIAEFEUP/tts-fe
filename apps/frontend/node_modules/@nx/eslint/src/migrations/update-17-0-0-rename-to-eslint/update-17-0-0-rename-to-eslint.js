"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = replacePackage;
const devkit_1 = require("@nx/devkit");
const replace_package_1 = require("@nx/devkit/src/utils/replace-package");
async function replacePackage(tree) {
    await (0, replace_package_1.replaceNrwlPackageWithNxPackage)(tree, '@nx/linter', '@nx/eslint');
    // executor name change from :eslint to :lint
    updateNxJsonExecutor(tree);
    updateProjectExecutor(tree);
    await (0, devkit_1.formatFiles)(tree);
}
function updateNxJsonExecutor(tree) {
    if (!tree.exists('nx.json')) {
        return;
    }
    const nxJson = (0, devkit_1.readNxJson)(tree);
    let needsUpdate = false;
    for (const [targetName, targetConfig] of Object.entries(nxJson.targetDefaults ?? {})) {
        // this will be in a broken state after the package is globally renamed
        if (targetConfig.executor !== '@nx/eslint:eslint') {
            continue;
        }
        needsUpdate = true;
        nxJson.targetDefaults[targetName].executor = '@nx/eslint:lint';
    }
    if (needsUpdate) {
        (0, devkit_1.updateNxJson)(tree, nxJson);
    }
}
function updateProjectExecutor(tree) {
    const projects = (0, devkit_1.getProjects)(tree);
    for (const [projectName, projectConfiguration] of projects) {
        let needsUpdate = false;
        for (const [targetName, targetConfig] of Object.entries(projectConfiguration.targets ?? {})) {
            // this will be in a broken state after the package is globally renamed
            if (targetConfig.executor !== '@nx/eslint:eslint') {
                continue;
            }
            needsUpdate = true;
            projectConfiguration.targets[targetName].executor = '@nx/eslint:lint';
        }
        if (needsUpdate) {
            (0, devkit_1.updateProjectConfiguration)(tree, projectName, projectConfiguration);
        }
    }
}
