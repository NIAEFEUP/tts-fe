"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = update;
const devkit_1 = require("@nx/devkit");
const versions_1 = require("../../utils/versions");
const path_1 = require("path");
const typescript_1 = require("typescript");
function updateJestConfig(tree) {
    const jestConfigPath = 'tools/eslint-rules/jest.config.ts';
    if (tree.exists(jestConfigPath)) {
        const { removePropertyFromJestConfig } = (0, devkit_1.ensurePackage)('@nx/jest', versions_1.nxVersion);
        removePropertyFromJestConfig(tree, jestConfigPath, [
            'moduleNameMapper',
            '@eslint/eslintrc',
        ]);
    }
}
function updateTsConfigs(tree) {
    const tsConfigPath = 'tools/eslint-rules/tsconfig.json';
    if (tree.exists(tsConfigPath)) {
        (0, devkit_1.updateJson)(tree, tsConfigPath, (tsConfig) => {
            tsConfig.compilerOptions ??= {};
            tsConfig.compilerOptions.moduleResolution = 'node16';
            tsConfig.compilerOptions.module = 'node16';
            return tsConfig;
        });
    }
    const tsConfigSpec = 'tools/eslint-rules/tsconfig.spec.json';
    if (tree.exists(tsConfigSpec)) {
        (0, devkit_1.updateJson)(tree, tsConfigSpec, (tsConfigSpec) => {
            delete tsConfigSpec.compilerOptions?.module;
            delete tsConfigSpec.compilerOptions?.moduleResolution;
            return tsConfigSpec;
        });
    }
}
function updateRecommended(tree) {
    (0, devkit_1.visitNotIgnoredFiles)(tree, 'tools/eslint-rules', (path) => {
        if ((0, path_1.extname)(path) !== '.ts') {
            return;
        }
        const contents = tree.read(path, 'utf-8');
        const sourceFile = (0, typescript_1.createSourceFile)(path, contents, typescript_1.ScriptTarget.ESNext, true);
        const changes = [];
        const visit = (node) => {
            if ((0, typescript_1.isPropertyAssignment)(node) &&
                (0, typescript_1.isIdentifier)(node.name) &&
                node.name.text === 'recommended' &&
                (0, typescript_1.isStringLiteral)(node.initializer)) {
                changes.push({
                    type: devkit_1.ChangeType.Delete,
                    start: node.initializer.getStart(sourceFile),
                    length: node.initializer.getWidth(sourceFile),
                });
                changes.push({
                    type: devkit_1.ChangeType.Insert,
                    index: node.initializer.getStart(sourceFile),
                    text: "'recommended'",
                });
            }
            else {
                (0, typescript_1.forEachChild)(node, visit);
            }
        };
        (0, typescript_1.forEachChild)(sourceFile, visit);
        tree.write(path, (0, devkit_1.applyChangesToString)(contents, changes));
    });
}
async function update(tree) {
    updateJestConfig(tree);
    updateTsConfigs(tree);
    updateRecommended(tree);
    await (0, devkit_1.formatFiles)(tree);
}
