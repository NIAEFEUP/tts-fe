{"version":3,"file":"startProfileForSpan.js","sources":["../../../../src/profiling/startProfileForSpan.ts"],"sourcesContent":["import { getCurrentScope, spanToJSON } from '@sentry/core';\nimport { logger, timestampInSeconds, uuid4 } from '@sentry/core';\nimport type { Span } from '@sentry/core';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport { WINDOW } from '../helpers';\nimport type { JSSelfProfile } from './jsSelfProfiling';\nimport { MAX_PROFILE_DURATION_MS, addProfileToGlobalCache, isAutomatedPageLoadSpan, startJSSelfProfile } from './utils';\n\n/**\n * Wraps startTransaction and stopTransaction with profiling related logic.\n * startProfileForTransaction is called after the call to startTransaction in order to avoid our own code from\n * being profiled. Because of that same reason, stopProfiling is called before the call to stopTransaction.\n */\nexport function startProfileForSpan(span: Span): void {\n  // Start the profiler and get the profiler instance.\n  let startTimestamp: number | undefined;\n  if (isAutomatedPageLoadSpan(span)) {\n    startTimestamp = timestampInSeconds() * 1000;\n  }\n\n  const profiler = startJSSelfProfile();\n\n  // We failed to construct the profiler, so we skip.\n  // No need to log anything as this has already been logged in startProfile.\n  if (!profiler) {\n    return;\n  }\n\n  if (DEBUG_BUILD) {\n    logger.log(`[Profiling] started profiling span: ${spanToJSON(span).description}`);\n  }\n\n  // We create \"unique\" span names to avoid concurrent spans with same names\n  // from being ignored by the profiler. From here on, only this span name should be used when\n  // calling the profiler methods. Note: we log the original name to the user to avoid confusion.\n  const profileId = uuid4();\n\n  // A couple of important things to note here:\n  // `CpuProfilerBindings.stopProfiling` will be scheduled to run in 30seconds in order to exceed max profile duration.\n  // Whichever of the two (span.finish/timeout) is first to run, the profiling will be stopped and the gathered profile\n  // will be processed when the original span is finished. Since onProfileHandler can be invoked multiple times in the\n  // event of an error or user mistake (calling span.finish multiple times), it is important that the behavior of onProfileHandler\n  // is idempotent as we do not want any timings or profiles to be overridden by the last call to onProfileHandler.\n  // After the original finish method is called, the event will be reported through the integration and delegated to transport.\n  const processedProfile: JSSelfProfile | null = null;\n\n  getCurrentScope().setContext('profile', {\n    profile_id: profileId,\n    start_timestamp: startTimestamp,\n  });\n\n  /**\n   * Idempotent handler for profile stop\n   */\n  async function onProfileHandler(): Promise<void> {\n    // Check if the profile exists and return it the behavior has to be idempotent as users may call span.finish multiple times.\n    if (!span) {\n      return;\n    }\n    // Satisfy the type checker, but profiler will always be defined here.\n    if (!profiler) {\n      return;\n    }\n    if (processedProfile) {\n      if (DEBUG_BUILD) {\n        logger.log('[Profiling] profile for:', spanToJSON(span).description, 'already exists, returning early');\n      }\n      return;\n    }\n\n    return profiler\n      .stop()\n      .then((profile: JSSelfProfile): void => {\n        if (maxDurationTimeoutID) {\n          WINDOW.clearTimeout(maxDurationTimeoutID);\n          maxDurationTimeoutID = undefined;\n        }\n\n        if (DEBUG_BUILD) {\n          logger.log(`[Profiling] stopped profiling of span: ${spanToJSON(span).description}`);\n        }\n\n        // In case of an overlapping span, stopProfiling may return null and silently ignore the overlapping profile.\n        if (!profile) {\n          if (DEBUG_BUILD) {\n            logger.log(\n              `[Profiling] profiler returned null profile for: ${spanToJSON(span).description}`,\n              'this may indicate an overlapping span or a call to stopProfiling with a profile title that was never started',\n            );\n          }\n          return;\n        }\n\n        addProfileToGlobalCache(profileId, profile);\n      })\n      .catch(error => {\n        if (DEBUG_BUILD) {\n          logger.log('[Profiling] error while stopping profiler:', error);\n        }\n      });\n  }\n\n  // Enqueue a timeout to prevent profiles from running over max duration.\n  let maxDurationTimeoutID: number | undefined = WINDOW.setTimeout(() => {\n    if (DEBUG_BUILD) {\n      logger.log('[Profiling] max profile duration elapsed, stopping profiling for:', spanToJSON(span).description);\n    }\n    // If the timeout exceeds, we want to stop profiling, but not finish the span\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    onProfileHandler();\n  }, MAX_PROFILE_DURATION_MS);\n\n  // We need to reference the original end call to avoid creating an infinite loop\n  const originalEnd = span.end.bind(span);\n\n  /**\n   * Wraps span `end()` with profiling related logic.\n   * startProfiling is called after the call to spanStart in order to avoid our own code from\n   * being profiled. Because of that same reason, stopProfiling is called before the call to spanEnd.\n   */\n  function profilingWrappedSpanEnd(): Span {\n    if (!span) {\n      return originalEnd();\n    }\n    // onProfileHandler should always return the same profile even if this is called multiple times.\n    // Always call onProfileHandler to ensure stopProfiling is called and the timeout is cleared.\n    void onProfileHandler().then(\n      () => {\n        originalEnd();\n      },\n      () => {\n        // If onProfileHandler fails, we still want to call the original finish method.\n        originalEnd();\n      },\n    );\n\n    return span;\n  }\n\n  span.end = profilingWrappedSpanEnd;\n}\n"],"names":["isAutomatedPageLoadSpan","timestampInSeconds","startJSSelfProfile","DEBUG_BUILD","logger","spanToJSON","uuid4","getCurrentScope","WINDOW","addProfileToGlobalCache","MAX_PROFILE_DURATION_MS"],"mappings":"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"}