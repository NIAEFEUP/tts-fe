{"version":3,"file":"interactions.js","sources":["../../../../../src/metrics/web-vitals/lib/interactions.ts"],"sourcesContent":["/*\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getInteractionCount } from './polyfills/interactionCountPolyfill';\n\ninterface Interaction {\n  id: number;\n  latency: number;\n  entries: PerformanceEventTiming[];\n}\n\ninterface EntryPreProcessingHook {\n  (entry: PerformanceEventTiming): void;\n}\n\n// A list of longest interactions on the page (by latency) sorted so the\n// longest one is first. The list is at most MAX_INTERACTIONS_TO_CONSIDER long.\nexport const longestInteractionList: Interaction[] = [];\n\n// A mapping of longest interactions by their interaction ID.\n// This is used for faster lookup.\nexport const longestInteractionMap: Map<number, Interaction> = new Map();\n\n// The default `durationThreshold` used across this library for observing\n// `event` entries via PerformanceObserver.\nexport const DEFAULT_DURATION_THRESHOLD = 40;\n\n// Used to store the interaction count after a bfcache restore, since p98\n// interaction latencies should only consider the current navigation.\nlet prevInteractionCount = 0;\n\n/**\n * Returns the interaction count since the last bfcache restore (or for the\n * full page lifecycle if there were no bfcache restores).\n */\nconst getInteractionCountForNavigation = () => {\n  return getInteractionCount() - prevInteractionCount;\n};\n\nexport const resetInteractions = () => {\n  prevInteractionCount = getInteractionCount();\n  longestInteractionList.length = 0;\n  longestInteractionMap.clear();\n};\n\n/**\n * Returns the estimated p98 longest interaction based on the stored\n * interaction candidates and the interaction count for the current page.\n */\nexport const estimateP98LongestInteraction = () => {\n  const candidateInteractionIndex = Math.min(\n    longestInteractionList.length - 1,\n    Math.floor(getInteractionCountForNavigation() / 50),\n  );\n\n  return longestInteractionList[candidateInteractionIndex];\n};\n\n// To prevent unnecessary memory usage on pages with lots of interactions,\n// store at most 10 of the longest interactions to consider as INP candidates.\nconst MAX_INTERACTIONS_TO_CONSIDER = 10;\n\n/**\n * A list of callback functions to run before each entry is processed.\n * Exposing this list allows the attribution build to hook into the\n * entry processing pipeline.\n */\nexport const entryPreProcessingCallbacks: EntryPreProcessingHook[] = [];\n\n/**\n * Takes a performance entry and adds it to the list of worst interactions\n * if its duration is long enough to make it among the worst. If the\n * entry is part of an existing interaction, it is merged and the latency\n * and entries list is updated as needed.\n */\nexport const processInteractionEntry = (entry: PerformanceEventTiming) => {\n  entryPreProcessingCallbacks.forEach(cb => cb(entry));\n\n  // Skip further processing for entries that cannot be INP candidates.\n  if (!(entry.interactionId || entry.entryType === 'first-input')) return;\n\n  // The least-long of the 10 longest interactions.\n  const minLongestInteraction = longestInteractionList[longestInteractionList.length - 1];\n\n  const existingInteraction = longestInteractionMap.get(entry.interactionId!);\n\n  // Only process the entry if it's possibly one of the ten longest,\n  // or if it's part of an existing interaction.\n  if (\n    existingInteraction ||\n    longestInteractionList.length < MAX_INTERACTIONS_TO_CONSIDER ||\n    (minLongestInteraction && entry.duration > minLongestInteraction.latency)\n  ) {\n    // If the interaction already exists, update it. Otherwise create one.\n    if (existingInteraction) {\n      // If the new entry has a longer duration, replace the old entries,\n      // otherwise add to the array.\n      if (entry.duration > existingInteraction.latency) {\n        existingInteraction.entries = [entry];\n        existingInteraction.latency = entry.duration;\n      } else if (\n        entry.duration === existingInteraction.latency &&\n        entry.startTime === (existingInteraction.entries[0] && existingInteraction.entries[0].startTime)\n      ) {\n        existingInteraction.entries.push(entry);\n      }\n    } else {\n      const interaction = {\n        id: entry.interactionId!,\n        latency: entry.duration,\n        entries: [entry],\n      };\n      longestInteractionMap.set(interaction.id, interaction);\n      longestInteractionList.push(interaction);\n    }\n\n    // Sort the entries by latency (descending) and keep only the top ten.\n    longestInteractionList.sort((a, b) => b.latency - a.latency);\n    if (longestInteractionList.length > MAX_INTERACTIONS_TO_CONSIDER) {\n      longestInteractionList.splice(MAX_INTERACTIONS_TO_CONSIDER).forEach(i => longestInteractionMap.delete(i.id));\n    }\n  }\n};\n"],"names":[],"mappings":"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"}