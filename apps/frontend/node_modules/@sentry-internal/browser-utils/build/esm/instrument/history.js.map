{"version":3,"file":"history.js","sources":["../../../src/instrument/history.ts"],"sourcesContent":["import { addHandler, fill, maybeInstrument, supportsHistory, triggerHandlers } from '@sentry/core';\nimport type { HandlerDataHistory } from '@sentry/core';\nimport { WINDOW } from '../types';\n\nlet lastHref: string | undefined;\n\n/**\n * Add an instrumentation handler for when a fetch request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addHistoryInstrumentationHandler(handler: (data: HandlerDataHistory) => void): void {\n  const type = 'history';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentHistory);\n}\n\nfunction instrumentHistory(): void {\n  if (!supportsHistory()) {\n    return;\n  }\n\n  const oldOnPopState = WINDOW.onpopstate;\n  WINDOW.onpopstate = function (this: WindowEventHandlers, ...args: unknown[]) {\n    const to = WINDOW.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n    const handlerData: HandlerDataHistory = { from, to };\n    triggerHandlers('history', handlerData);\n    if (oldOnPopState) {\n      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.\n      // https://github.com/getsentry/sentry-javascript/issues/3344\n      // https://github.com/bugsnag/bugsnag-js/issues/469\n      try {\n        return oldOnPopState.apply(this, args);\n      } catch (_oO) {\n        // no-empty\n      }\n    }\n  };\n\n  function historyReplacementFunction(originalHistoryFunction: () => void): () => void {\n    return function (this: History, ...args: unknown[]): void {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        const handlerData: HandlerDataHistory = { from, to };\n        triggerHandlers('history', handlerData);\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(WINDOW.history, 'pushState', historyReplacementFunction);\n  fill(WINDOW.history, 'replaceState', historyReplacementFunction);\n}\n"],"names":[],"mappings":";;;AAIA,IAAI,QAAQ;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,gCAAgC,CAAC,OAAO,EAA4C;AACpG,EAAE,MAAM,IAAK,GAAE,SAAS;AACxB,EAAE,UAAU,CAAC,IAAI,EAAE,OAAO,CAAC;AAC3B,EAAE,eAAe,CAAC,IAAI,EAAE,iBAAiB,CAAC;AAC1C;;AAEA,SAAS,iBAAiB,GAAS;AACnC,EAAE,IAAI,CAAC,eAAe,EAAE,EAAE;AAC1B,IAAI;AACJ;;AAEA,EAAE,MAAM,aAAA,GAAgB,MAAM,CAAC,UAAU;AACzC,EAAE,MAAM,CAAC,UAAW,GAAE,WAAqC,GAAG,IAAI,EAAa;AAC/E,IAAI,MAAM,EAAG,GAAE,MAAM,CAAC,QAAQ,CAAC,IAAI;AACnC;AACA,IAAI,MAAM,IAAK,GAAE,QAAQ;AACzB,IAAI,QAAA,GAAW,EAAE;AACjB,IAAI,MAAM,WAAW,GAAuB,EAAE,IAAI,EAAE,IAAI;AACxD,IAAI,eAAe,CAAC,SAAS,EAAE,WAAW,CAAC;AAC3C,IAAI,IAAI,aAAa,EAAE;AACvB;AACA;AACA;AACA,MAAM,IAAI;AACV,QAAQ,OAAO,aAAa,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC;AAC9C,OAAQ,CAAA,OAAO,GAAG,EAAE;AACpB;AACA;AACA;AACA,GAAG;;AAEH,EAAE,SAAS,0BAA0B,CAAC,uBAAuB,EAA0B;AACvF,IAAI,OAAO,WAAyB,GAAG,IAAI,EAAmB;AAC9D,MAAM,MAAM,GAAA,GAAM,IAAI,CAAC,MAAO,GAAE,CAAE,GAAE,IAAI,CAAC,CAAC,CAAA,GAAI,SAAS;AACvD,MAAM,IAAI,GAAG,EAAE;AACf;AACA,QAAQ,MAAM,IAAK,GAAE,QAAQ;AAC7B,QAAQ,MAAM,EAAG,GAAE,MAAM,CAAC,GAAG,CAAC;AAC9B;AACA,QAAQ,QAAA,GAAW,EAAE;AACrB,QAAQ,MAAM,WAAW,GAAuB,EAAE,IAAI,EAAE,IAAI;AAC5D,QAAQ,eAAe,CAAC,SAAS,EAAE,WAAW,CAAC;AAC/C;AACA,MAAM,OAAO,uBAAuB,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC;AACtD,KAAK;AACL;;AAEA,EAAE,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,WAAW,EAAE,0BAA0B,CAAC;AAC/D,EAAE,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,cAAc,EAAE,0BAA0B,CAAC;AAClE;;;;"}